Option Explicit

'--------------------------------------------------------------------------------------------
' MAIN: Refresh Smart View hierarchies, then build queries
'--------------------------------------------------------------------------------------------
Public Sub RefreshHierarchiesAndCreateQueries()
    On Error GoTo errHandler
    
    LogMessage "RefreshHierarchiesAndCreateQueries", "INFO", "Process started."
    
    ' 1) Refresh each sheet (original working version)
    RefreshSmartViewTree
    
    ' 2) Create queries that do row removal in M code, then bottom-up logic, then reverse
    CreateHierarchyQueries
    
    LogMessage "RefreshHierarchiesAndCreateQueries", "INFO", "Process completed successfully."
    Exit Sub

errHandler:
    LogError "RefreshHierarchiesAndCreateQueries", Err.Number, Err.Description
End Sub

'--------------------------------------------------------------------------------------------
' REFRESH SMART VIEW HIERARCHIES (your original code snippet)
'--------------------------------------------------------------------------------------------
Public Sub RefreshSmartViewTree()
    On Error GoTo errHandler
    
    Dim arrSheets As Variant
    Dim ws As Worksheet
    Dim wsLists As Worksheet
    Dim ConnectionName As String
    Dim Ret As Long, HeaderRow As Long, LastRow As Long, i As Long
    Dim ConnStatus As Integer
    
    ' 1) "Lists" sheet
    Set wsLists = ThisWorkbook.Worksheets("Lists")
    
    With wsLists
        ConnectionName = .Range("nmConnectionName").Value
        arrSheets = .Range("Hierarchy_Matrix").Value
    End With
    
    HeaderRow = 4
    
    ' Loop
    For i = LBound(arrSheets) To UBound(arrSheets)
        Set ws = ThisWorkbook.Worksheets(arrSheets(i, 1))
        
        With ws
            Ret = HypUIConnect(.Name, "", "", ConnectionName)
            ConnStatus = HypConnected(.Name)
            If ConnStatus <> -1 Then Stop  ' your debug

            ' Delete old rows except final
            LastRow = .Range("A" & .Rows.Count).End(xlUp).Row
            If LastRow > HeaderRow Then
                .Rows(HeaderRow & ":" & (LastRow - 1)).Delete Shift:=xlUp
            End If

            ' Zoom in
            LastRow = .Range("A" & .Rows.Count).End(xlUp).Row
            Ret = HypSetSheetOption(.Name, HYP_SVC_OPTIONS_INDEX.HSV_MEMBER_DISPLAY, 1)
            Ret = HypZoomIn(.Name, .Range("A" & LastRow), 1, False)
            
            ' Final last row
            LastRow = .Range("A" & .Rows.Count).End(xlUp).Row
            
            ' Delete the old named range if it exists
            On Error Resume Next
            ThisWorkbook.Names(arrSheets(i, 2)).Delete
            On Error GoTo 0
            
            ' Create the new named range from row4..LastRow
            ThisWorkbook.Names.Add Name:=arrSheets(i, 2), _
                RefersTo:=.Range("A" & HeaderRow & ":A" & LastRow)
        End With
    Next i
    
    LogMessage "RefreshSmartViewTree", "INFO", "Smart View tree refresh done."
    Exit Sub

errHandler:
    LogError "RefreshSmartViewTree", Err.Number, Err.Description
End Sub

'--------------------------------------------------------------------------------------------
' CREATE HIERARCHY QUERIES
' Each query references the named range, does M-code:
'   - Removes last 1 or 2 rows if "Tree" or "List"
'   - bottom-up parent detection
'   - then ReverseRows for final bottom->top order
'--------------------------------------------------------------------------------------------
Public Sub CreateHierarchyQueries()
    On Error GoTo errHandler
    
    LogMessage "CreateHierarchyQueries", "INFO", "Starting to create or update queries."
    
    Dim wsLists As Worksheet
    Dim arrSheets As Variant
    Dim i As Long
    Dim rangeName As String
    Dim queryName As String
    Dim queryText As String
    Dim sheetName As String
    Dim ws As Worksheet
    Dim treeOrList As String
    
    Set wsLists = ThisWorkbook.Worksheets("Lists")
    arrSheets = wsLists.Range("Hierarchy_Matrix").Value
    
    For i = LBound(arrSheets) To UBound(arrSheets)
        sheetName = Trim(arrSheets(i, 1))
        rangeName = Trim(arrSheets(i, 2))
        
        ' skip if empty
        If sheetName = "" Or rangeName = "" Then GoTo NextQuery
        
        queryName = sheetName & "_FlatTable"
        
        ' find the sheet
        Set ws = ThisWorkbook.Worksheets(sheetName)
        
        ' get Tree/List from D7 (uppercased)
        treeOrList = UCase(Trim(ws.Range("D7").Value))
        
        ' build the M code
        queryText = BuildBottomUpParentQuery(rangeName, treeOrList)
        
        ' update or create query
        On Error Resume Next
        ThisWorkbook.Queries(queryName).Formula = queryText
        
        If Err.Number <> 0 Then
            ' error => try deleting old connection, then create
            On Error Resume Next
            ThisWorkbook.Connections(queryName).Delete
            On Error GoTo 0
            
            ThisWorkbook.Queries.Add Name:=queryName, Formula:=queryText
        End If
        On Error GoTo 0
        
        LogMessage "CreateHierarchyQueries", "INFO", _
                   "Sheet='" & sheetName & "', Query='" & queryName & "', Tree/List='" & treeOrList & "'"
        
NextQuery:
    Next i
    
    LogMessage "CreateHierarchyQueries", "INFO", "Queries creation done."
    Exit Sub

errHandler:
    LogError "CreateHierarchyQueries", Err.Number, Err.Description
End Sub

'--------------------------------------------------------------------------------------------
' BUILD BOTTOM-UP INDENT PARENT QUERY
' - "Tree" => remove last 1 row in M code
' - "List" => remove last 2 rows
' - Then do parent detection from bottom to top, then ReverseRows so final result
'   is from "bottom" to "top."
'--------------------------------------------------------------------------------------------
Public Function BuildBottomUpParentQuery(rangeName As String, treeOrList As String) As String
    Dim skipRows As Long
    
    If treeOrList = "TREE" Then
        skipRows = 1
    ElseIf treeOrList = "LIST" Then
        skipRows = 2
    Else
        skipRows = 0
    End If
    
    Dim mCode As String
    mCode = ""
    mCode = mCode & "let" & vbCrLf
    mCode = mCode & "    Source = Excel.CurrentWorkbook(){[Name=""" & rangeName & """]}[Content]," & vbCrLf
    mCode = mCode & "    rowCount = Table.RowCount(Source)," & vbCrLf
    mCode = mCode & "    keepRows = if rowCount > " & skipRows & _
                   " then Table.FirstN(Source, rowCount - " & skipRows & ") else Source," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // filter blank lines" & vbCrLf
    mCode = mCode & "    nonBlank = Table.SelectRows(keepRows, each [Column1] <> null and [Column1] <> """")," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // We'll keep them in top->bottom order for a moment," & vbCrLf
    mCode = mCode & "    // but do bottom-up detection => easier if we ReverseRows then add an Index" & vbCrLf
    mCode = mCode & "    reversed = Table.ReverseRows(nonBlank)," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // add Index from bottom->top" & vbCrLf
    mCode = mCode & "    withIndex = Table.AddIndexColumn(reversed, ""RowIndex"", 0, 1, Int64.Type)," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // detect indentation" & vbCrLf
    mCode = mCode & "    withIndent = Table.AddColumn(withIndex, ""Indent"", each Text.Length([Column1]) - Text.Length(Text.TrimStart([Column1])), Int64.Type)," & vbCrLf
    mCode = mCode & "    withValue = Table.AddColumn(withIndent, ""Value"", each Text.Trim([Column1]), type text)," & vbCrLf
    mCode = mCode & "    core = Table.SelectColumns(withValue, {""RowIndex"", ""Indent"", ""Value""})," & vbCrLf
    mCode = mCode & "    bufferCore = Table.Buffer(core)," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // For each row => find row with a bigger RowIndex that has smaller Indent => that's the 'Parent'" & vbCrLf
    mCode = mCode & "    // Because we reversed, a 'bigger RowIndex' is actually further up in the original list." & vbCrLf
    mCode = mCode & "    withParent = Table.AddColumn(bufferCore, ""Parent"", (thisRow) => let" & vbCrLf
    mCode = mCode & "        myIdx = thisRow[RowIndex]," & vbCrLf
    mCode = mCode & "        myIndent = thisRow[Indent]," & vbCrLf
    mCode = mCode & "        candidates = Table.SelectRows(bufferCore, each [RowIndex] > myIdx and [Indent] < myIndent)," & vbCrLf
    mCode = mCode & "        // pick the first in ascending RowIndex => the closest up in the original list" & vbCrLf
    mCode = mCode & "        ordered = Table.Sort(candidates, {{""RowIndex"", Order.Ascending}})," & vbCrLf
    mCode = mCode & "        result = if Table.IsEmpty(ordered) then null else ordered{0}[Value]" & vbCrLf
    mCode = mCode & "    in result )," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // our table is reversed. We want final result in reversed order => actually we keep it reversed" & vbCrLf
    mCode = mCode & "    final = withParent" & vbCrLf
    mCode = mCode & "in" & vbCrLf
    mCode = mCode & "    final"
    
    BuildBottomUpParentQuery = mCode
End Function


'--------------------------------------------------------------------------------------------
' LOG SHEET
'--------------------------------------------------------------------------------------------
Public Sub LogMessage(procName As String, msgType As String, message As String)
    Dim wsLog As Worksheet
    Dim nextRow As Long
    
    On Error Resume Next
    Set wsLog = ThisWorkbook.Worksheets("Log")
    On Error GoTo 0
    
    If wsLog Is Nothing Then
        Set wsLog = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
        wsLog.Name = "Log"
        wsLog.Range("A1").Value = "Timestamp"
        wsLog.Range("B1").Value = "Procedure"
        wsLog.Range("C1").Value = "Type"
        wsLog.Range("D1").Value = "Message"
    End If
    
    nextRow = wsLog.Cells(wsLog.Rows.Count, "A").End(xlUp).Row + 1
    
    wsLog.Cells(nextRow, 1).Value = Format(Now, "yyyy-mm-dd HH:mm:ss")
    wsLog.Cells(nextRow, 2).Value = procName
    wsLog.Cells(nextRow, 3).Value = msgType
    wsLog.Cells(nextRow, 4).Value = message
End Sub

Public Sub LogError(procName As String, errNumber As Long, errDescription As String)
    LogMessage procName, "ERROR", "Error #" & errNumber & ": " & errDescription
End Sub
