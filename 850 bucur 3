#!/usr/bin/env python3
"""
Ultra-Mega Reconciliation (Name-first + Single Mismatch Sheet + Red Theme + Full Dashboard + HistoryTab)

Key points:
1) Name-first comparison:
   - If Name missing/diff => single row => skip other attributes
   - If Name matches => compare all other attributes
   - If mismatch is case-only => Status="CASE" (but in same mismatch sheet)
2) Only one sheet: "Mismatch" with a red color theme.
3) SimplePreview (ERP & Master) with future-end-date toggle includes blank end dates and year>2200, "9999," or >=today.
4) AdvancedDashboard to view mismatch items (including "CASE").
5) HistoryTab to load & view older runs (JSON).
6) Partial PDF generator for a cover and summary.
"""

import os
import sys
import json
import logging
import zipfile
import shutil
import io
from pathlib import Path
from datetime import datetime, date
from typing import Dict, Set, List, Tuple

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import customtkinter as ctk

import pandas as pd
import numpy as np

import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

from openpyxl import Workbook
from openpyxl.styles import PatternFill, Font, Alignment
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.utils import get_column_letter

# ----------------------------------------------------------------------------
# LOGGING
# ----------------------------------------------------------------------------
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# ----------------------------------------------------------------------------
# DEFAULT CONFIG
# ----------------------------------------------------------------------------
DEFAULT_PATHS = {
    "ERP_EXCEL_PATH": "data/ERP_Config.xlsx",
    "MASTER_ZIP_PATH": "data/Master_Config.zip",
    "MASTER_TXT_FOLDER": "",
    "EXCEPTION_PATH": "data/Exception_Table.xlsx",
    "OUTPUT_PATH": "output/missing_items.xlsx",
    "CONFIG_PATH": "config/ui_config.json",
    "PARAMETER_PATH": "data/parameters.xlsx",
    "MASTER_CSV_OUTPUT": "temp_master_csv",
    "PDF_EXPORT_PATH": "output/dashboard_report.pdf",
    "LOGO_PATH": "images/company_logo.png",
    "HISTORY_PATH": "history_runs"
}

def default_config() -> Dict:
    return {
        "paths": DEFAULT_PATHS.copy(),
        "erp_grid": {"filters": {}},
        "master_grid": {"filters": {}},
        "dashboard": {
            "selected_dims": [],
            "selected_attrs": [],
            "top_n": 10
        },
        "trim_key_toggle": False
    }

def load_config(path: Path) -> Dict:
    if path.is_file():
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logging.warning(f"Could not load config => {e}")
    return default_config()

def save_config(cfg: Dict, path: Path):
    path.parent.mkdir(parents=True, exist_ok=True)
    try:
        # Convert sets->lists for erp_grid
        if "erp_grid" in cfg and "filters" in cfg["erp_grid"]:
            newf={}
            for c,svals in cfg["erp_grid"]["filters"].items():
                newf[c]= list(svals)
            cfg["erp_grid"]["filters"]= newf
        # Convert sets->lists for master_grid
        if "master_grid" in cfg and "filters" in cfg["master_grid"]:
            newf={}
            for c,svals in cfg["master_grid"]["filters"].items():
                newf[c]= list(svals)
            cfg["master_grid"]["filters"]= newf

        with open(path,"w",encoding="utf-8") as f:
            json.dump(cfg, f, indent=2)
        logging.info(f"Saved config => {path}")
    except Exception as e:
        logging.error(f"Error saving config => {e}")


# ----------------------------------------------------------------------------
# TEXT LOGGER
# ----------------------------------------------------------------------------
class TextHandler(logging.Handler):
    def __init__(self, widget: ctk.CTkTextbox):
        super().__init__()
        self.widget= widget

    def emit(self, record):
        msg= self.format(record)+ "\n"
        self.widget.after(0, self._append, msg)

    def _append(self, msg):
        self.widget.configure(state="normal")
        self.widget.insert("end", msg)
        self.widget.see("end")
        self.widget.configure(state="disabled")


# ----------------------------------------------------------------------------
# FILE READ UTILS
# ----------------------------------------------------------------------------
import pandas as pd

def read_erp_excel(path: Path)-> pd.DataFrame:
    if not path.is_file():
        logging.warning(f"ERP Excel not found => {path}")
        return pd.DataFrame()
    try:
        df= pd.read_excel(path, skiprows=3)
        df.columns= df.columns.str.strip()
        if "Enabled_Flag" in df.columns:
            df= df[df["Enabled_Flag"]=="Enabled"]
        return df
    except Exception as e:
        logging.error(f"Error reading ERP => {e}")
        return pd.DataFrame()

def try_read_csv_bytes(raw: bytes)-> pd.DataFrame:
    encs= ["utf-8-sig","utf-16-le","utf-16-be","cp1252","latin-1","ascii"]
    import io
    for enc in encs:
        try:
            buf= io.BytesIO(raw)
            df= pd.read_csv(buf, encoding=enc, on_bad_lines="skip", engine="python")
            df.dropna(how="all",axis=0,inplace=True)
            df.dropna(how="all",axis=1,inplace=True)
            df.columns= df.columns.astype(str).str.strip()
            if "Name" not in df.columns and len(df.columns)>0:
                fc= df.columns[0]
                df.rename(columns={fc:"Name"}, inplace=True)
            return df
        except:
            pass
    logging.error("[try_read_csv_bytes] => all enc fail => empty DF")
    return pd.DataFrame()

def convert_master_txt_to_csv(zip_path: Path, out_dir: Path)-> List[Path]:
    if not zip_path.is_file():
        logging.warning(f"Master ZIP not found => {zip_path}")
        return []
    if out_dir.exists():
        shutil.rmtree(out_dir, ignore_errors=True)
    out_dir.mkdir(parents=True, exist_ok=True)
    csvs=[]
    with zipfile.ZipFile(zip_path,"r") as z:
        txt_files= [f for f in z.namelist() if f.lower().endswith(".txt")]
        for txt_file in txt_files:
            bn= os.path.basename(txt_file)
            if not bn:
                continue
            try:
                with z.open(txt_file) as fo:
                    raw= fo.read()
                df= try_read_csv_bytes(raw)
                if df.empty:
                    continue
                df["RawFileName"]= bn
                out_csv= out_dir/(bn.replace(".txt",".csv"))
                df.to_csv(out_csv,index=False,encoding="utf-8")
                csvs.append(out_csv)
            except Exception as e:
                logging.error(f"Error reading {txt_file} => {e}")
    return csvs

def unify_master_csvs(csvs: List[Path])-> pd.DataFrame:
    frames=[]
    for c in csvs:
        if not c.is_file():
            continue
        try:
            df= pd.read_csv(c, encoding="utf-8", on_bad_lines="skip")
            df.columns= df.columns.str.strip()
            frames.append(df)
        except Exception as e:
            logging.error(f"unify_master_csvs => {c} => {e}")
    if frames:
        return pd.concat(frames, ignore_index=True)
    return pd.DataFrame()

def unify_master_txt_in_folder(folder: Path)-> pd.DataFrame:
    if not folder.is_dir():
        logging.warning(f"Master folder not found => {folder}")
        return pd.DataFrame()
    txt_files= list(folder.glob("*.txt"))
    if not txt_files:
        logging.warning(f"No .txt => {folder}")
        return pd.DataFrame()
    frames=[]
    for f in txt_files:
        try:
            raw= f.read_bytes()
            df= try_read_csv_bytes(raw)
            if not df.empty:
                df["RawFileName"]= f.name
                frames.append(df)
        except Exception as e:
            logging.error(f"Reading {f} => {e}")
    if frames:
        return pd.concat(frames, ignore_index=True)
    return pd.DataFrame()


# ----------------------------------------------------------------------------
# PARAMS
# ----------------------------------------------------------------------------
def read_param_file(path: Path)-> Dict[str,object]:
    param= {
        "dim_erp_keep": set(),
        "dim_erp_map": {},
        "dim_master_map": {},
        "attr_erp_map": {},
        "attr_master_map": {}
    }
    if not path.is_file():
        logging.warning(f"Param file not found => {path}")
        return param
    try:
        dim_df= pd.read_excel(path, sheet_name="Dimension Parameters")
        dim_df.columns= dim_df.columns.astype(str).str.strip()

        def s(x): return str(x).strip() if pd.notna(x) else ""
        for _, row in dim_df.iterrows():
            fn= s(row.get("FileName",""))
            vsc= s(row.get("V S C",""))
            dim= s(row.get("Dimension",""))
            ev= s(row.get("ERP Values",""))
            if ev.lower()=="x" and vsc and dim:
                param["dim_erp_keep"].add(vsc)
            if vsc and dim:
                param["dim_erp_map"][vsc]= dim
            if fn and dim and ev.lower()=="x":
                param["dim_master_map"][fn]= dim

        attr_df= pd.read_excel(path, sheet_name="Attribute Parameters")
        attr_df.columns= attr_df.columns.astype(str).str.strip()
        for _, row in attr_df.iterrows():
            e_orig= s(row.get("ERP Original Attributes",""))
            m_orig= s(row.get("Master Original Attributes",""))
            final_= s(row.get("Attribute",""))
            onoff= s(row.get("On/Off",""))
            if onoff.lower()=="x" and final_:
                if e_orig:
                    param["attr_erp_map"][e_orig]= final_
                if m_orig:
                    param["attr_master_map"][m_orig]= final_
        return param
    except Exception as e:
        logging.error(f"read_param_file => {e}")
        return param


# ----------------------------------------------------------------------------
# MELTDOWN
# ----------------------------------------------------------------------------
def meltdown_erp_for_preview(df: pd.DataFrame, param: Dict[str,object])-> pd.DataFrame:
    if "V_S_C" not in df.columns:
        return pd.DataFrame()
    keep= param["dim_erp_keep"]
    dmap= param["dim_erp_map"]
    amap= param["attr_erp_map"]

    df2= df[df["V_S_C"].isin(keep)].copy()
    if df2.empty:
        return pd.DataFrame()

    skip= {"V_S_C","Enabled_Flag"}
    id_vars=[]
    if "Value" in df2.columns:
        id_vars.append("Value")
        skip.add("Value")
    df2["DimRaw"]= df2["V_S_C"]
    skip.add("DimRaw")
    id_vars.insert(0,"DimRaw")

    meltdown_cols= [c for c in df2.columns if c not in skip]
    melted= df2.melt(
        id_vars=id_vars,
        value_vars= meltdown_cols,
        var_name="OrigAttr",
        value_name="ValX"
    )

    def ren_dim(x):
        return dmap.get(x,x)
    melted["Dimension"]= melted["DimRaw"].apply(ren_dim)

    if "Value" in id_vars:
        melted.rename(columns={"Value":"Name"}, inplace=True)
    else:
        melted["Name"]= ""

    # filter by attr map
    melted= melted[melted["OrigAttr"].isin(amap.keys())].copy()
    melted["Attribute"]= melted["OrigAttr"].map(amap)

    def strip_t(val):
        if isinstance(val,str) and "T" in val:
            return val.split("T")[0]
        return val
    melted["Value"]= np.where(
        melted["Attribute"].isin(["Start Date","End Date"]),
        melted["ValX"].apply(strip_t),
        melted["ValX"]
    )
    return melted[["Dimension","Name","Attribute","Value"]]

def meltdown_master_for_preview(df: pd.DataFrame, param: Dict[str,object])-> pd.DataFrame:
    if df.empty or "RawFileName" not in df.columns:
        return pd.DataFrame()
    keep_map= param["dim_master_map"]
    amap= param["attr_master_map"]

    df2= df[df["RawFileName"].isin(keep_map.keys())].copy()
    if df2.empty:
        return pd.DataFrame()

    df2["DimRaw"]= df2["RawFileName"]
    skip= {"RawFileName","DimRaw"}
    id_vars=["DimRaw"]
    if "Name" in df2.columns:
        id_vars.append("Name")
        skip.add("Name")

    meltdown_cols= [c for c in df2.columns if c not in skip]
    melted= df2.melt(
        id_vars=id_vars,
        value_vars= meltdown_cols,
        var_name="OrigAttr",
        value_name="ValX"
    )

    def ren_dim(x):
        return keep_map.get(x,x)
    melted["Dimension"]= melted["DimRaw"].apply(ren_dim)

    if "Name" in id_vars:
        melted.rename(columns={"Name":"Name"}, inplace=True)
    else:
        melted["Name"]= ""

    amap_keys= set(amap.keys())
    melted= melted[melted["OrigAttr"].isin(amap_keys)].copy()
    melted["Attribute"]= melted["OrigAttr"].map(amap)

    def strip_t(val):
        if isinstance(val,str) and "T" in val:
            return val.split("T")[0]
        return val
    melted["Value"]= np.where(
        melted["Attribute"].isin(["Start Date","End Date"]),
        melted["ValX"].apply(strip_t),
        melted["ValX"]
    )
    return melted[["Dimension","Name","Attribute","Value"]]

def pivot_for_preview(df: pd.DataFrame)-> pd.DataFrame:
    if df.empty or not {"Dimension","Name","Attribute"}.issubset(df.columns):
        return pd.DataFrame()
    df2= df.drop_duplicates(subset=["Dimension","Name","Attribute"])
    try:
        out= df2.pivot(index=["Dimension","Name"], columns="Attribute", values="Value").reset_index()
        return out
    except:
        return pd.DataFrame()

def meltdown_to_long(df_wide: pd.DataFrame)-> pd.DataFrame:
    if df_wide.empty or {"Dimension","Name"}.difference(df_wide.columns):
        return pd.DataFrame()
    meltdown_cols= [c for c in df_wide.columns if c not in ("Dimension","Name")]
    melted= df_wide.melt(
        id_vars=["Dimension","Name"],
        value_vars= meltdown_cols,
        var_name="Attribute",
        value_name="Value"
    )
    melted["Value"]= melted["Value"].fillna("")
    return melted

# ----------------------------------------------------------------------------
# NAME-FIRST single mismatch
# ----------------------------------------------------------------------------
def compare_name_attribute(
    erp_long: pd.DataFrame,
    mast_long: pd.DataFrame,
    trim_key=False
)-> pd.DataFrame:
    """
    Name-first logic => single mismatch DataFrame
    If Name missing/diff => one row => skip attributes
    If same => compare rest
    case-only => Status="CASE"
    """
    def build_dict(d: pd.DataFrame):
        out={}
        for (dim,nm), grp in d.groupby(["Dimension","Name"]):
            rec={}
            for _, row in grp.iterrows():
                rec[row["Attribute"]]= row["Value"]
            out[(dim,nm)] = rec
        return out
    e_dict= build_dict(erp_long)
    m_dict= build_dict(mast_long)

    all_rows=[]
    all_keys= set(e_dict.keys())| set(m_dict.keys())

    for dnm in all_keys:
        dim,nm= dnm
        e_map= e_dict.get(dnm,{})
        m_map= m_dict.get(dnm,{})
        e_name= e_map.get("Name","")
        m_name= m_map.get("Name","")

        name_issue=False
        # Missing in ERP
        if dnm not in e_dict and dnm in m_dict:
            row= {
                "Dimension": dim,
                "Name": nm,
                "Attribute": "Name",
                "Master": m_name,
                "ERP": "",
                "Comments_1": "",
                "Comments_2": "",
                "Status": "Missing in ERP"
            }
            raw= f"{dim}|{nm}|Name|{m_name}|".upper()
            if trim_key: raw= raw.replace(" ","")
            row["Key"]= raw
            all_rows.append(row)
            name_issue=True
        # Missing in Master
        elif dnm in e_dict and dnm not in m_dict:
            row= {
                "Dimension": dim,
                "Name": nm,
                "Attribute": "Name",
                "Master": "",
                "ERP": e_name,
                "Comments_1": "",
                "Comments_2": "",
                "Status": "Missing in Master"
            }
            raw= f"{dim}|{nm}|Name||{e_name}".upper()
            if trim_key: raw= raw.replace(" ","")
            row["Key"]= raw
            all_rows.append(row)
            name_issue=True
        # Both exist => but differ
        elif e_name and m_name and e_name!= m_name:
            if e_name.lower()== m_name.lower():
                st="CASE"
            else:
                st="Difference in both"
            row= {
                "Dimension": dim,
                "Name": nm,
                "Attribute": "Name",
                "Master": m_name,
                "ERP": e_name,
                "Comments_1": "",
                "Comments_2": "",
                "Status": st
            }
            raw= f"{dim}|{nm}|Name|{m_name}|{e_name}".upper()
            if trim_key: raw= raw.replace(" ","")
            row["Key"]= raw
            all_rows.append(row)
            name_issue=True

        if name_issue:
            # skip other attributes
            continue

        # if name matches => compare other attributes
        all_atts= set(e_map.keys())| set(m_map.keys())
        all_atts.discard("Name")
        for att in all_atts:
            ev= e_map.get(att,"")
            mv= m_map.get(att,"")
            if ev.lower()== mv.lower() and ev!=mv and ev and mv:
                st="CASE"
            elif ev and not mv:
                st="Missing in Master"
            elif mv and not ev:
                st="Missing in ERP"
            elif ev!= mv:
                st="Difference in both"
            else:
                continue

            row= {
                "Dimension": dim,
                "Name": nm,
                "Attribute": att,
                "Master": mv,
                "ERP": ev,
                "Comments_1": "",
                "Comments_2": "",
                "Status": st
            }
            raw= f"{dim}|{nm}|{att}|{mv}|{ev}".upper()
            if trim_key: raw= raw.replace(" ","")
            row["Key"]= raw
            all_rows.append(row)

    mismatch_cols= ["Key","Dimension","Name","Attribute","Master","ERP","Comments_1","Comments_2","Status"]
    if not all_rows:
        return pd.DataFrame(columns=mismatch_cols)
    outdf= pd.DataFrame(all_rows)
    return outdf[mismatch_cols]


# ----------------------------------------------------------------------------
# EXCEPTIONS
# ----------------------------------------------------------------------------
def read_exception_table(path: Path)-> pd.DataFrame:
    if not path.is_file():
        logging.warning(f"No exceptions => {path}")
        return pd.DataFrame()
    try:
        df= pd.read_excel(path)
        df.columns= df.columns.astype(str).str.strip()
        return df
    except:
        return pd.DataFrame()

def merge_exceptions(df: pd.DataFrame, exc: pd.DataFrame)-> pd.DataFrame:
    if df.empty or exc.empty or "Key" not in df.columns:
        return df
    keep= [c for c in ["Key","Comments_1","Comments_2","hide exception"] if c in exc.columns]
    if not keep:
        return df
    exc_= exc[keep].copy()
    exc_["Key"]= exc_["Key"].astype(str).str.strip()
    merged= df.merge(exc_, on="Key", how="left", suffixes=("","_exc"))
    merged["hide exception"]= merged.get("hide exception","").fillna("").str.lower()
    final= merged[merged["hide exception"]!="yes"].copy()
    if "Comments_1_exc" in final.columns:
        final["Comments_1"]= np.where(final["Comments_1_exc"].notna(),
                                      final["Comments_1_exc"],
                                      final["Comments_1"])
        final.drop(columns=["Comments_1_exc"], inplace=True)
    if "Comments_2_exc" in final.columns:
        final["Comments_2"]= np.where(final["Comments_2_exc"].notna(),
                                      final["Comments_2_exc"],
                                      final["Comments_2"])
        final.drop(columns=["Comments_2_exc"], inplace=True)
    if "hide exception" in final.columns:
        final.drop(columns=["hide exception"], inplace=True)
    return final

# ----------------------------------------------------------------------------
# WRITE SINGLE-SHEET => RED
# ----------------------------------------------------------------------------
def write_1sheet_excel(mismatch_df: pd.DataFrame, out_path: Path):
    """
    Single sheet: "Mismatch", red color theme, including "CASE" in same sheet
    """
    out_path.parent.mkdir(parents=True, exist_ok=True)
    columns= ["Key","Dimension","Name","Attribute","Master","ERP","Comments_1","Comments_2","Status"]

    wb= Workbook()
    ws= wb.active
    ws.title= "Mismatch"

    for c in columns:
        if c not in mismatch_df.columns:
            mismatch_df[c]= ""
    ws.append(columns)
    for rowvals in mismatch_df[columns].itertuples(index=False):
        ws.append(rowvals)

    # header => dark red, white text
    hdr_font= Font(bold=True, color="FFFFFF")
    hdr_fill= PatternFill(start_color="B30000", end_color="B30000", fill_type="solid")
    for cell in ws[1]:
        cell.font= hdr_font
        cell.fill= hdr_fill
        cell.alignment= Alignment(horizontal="center")

    # data => row fill by status
    c_missing_master= PatternFill(start_color="FFD2D2", end_color="FFD2D2", fill_type="solid")
    c_missing_erp   = PatternFill(start_color="FF9999", end_color="FF9999", fill_type="solid")
    c_diff_both     = PatternFill(start_color="FF6666", end_color="FF6666", fill_type="solid")
    c_case          = PatternFill(start_color="FF4D4D", end_color="FF4D4D", fill_type="solid")
    c_default       = PatternFill(start_color="FFCCCC", end_color="FFCCCC", fill_type="solid")

    if ws.max_row>1:
        stat_idx= columns.index("Status")+1
        for r in range(2, ws.max_row+1):
            st_val= ws.cell(r, stat_idx).value
            if st_val=="Missing in Master":
                fillc= c_missing_master
            elif st_val=="Missing in ERP":
                fillc= c_missing_erp
            elif st_val=="Difference in both":
                fillc= c_diff_both
            elif st_val=="CASE":
                fillc= c_case
            else:
                fillc= c_default

            for c_ in range(1, ws.max_column+1):
                cell_= ws.cell(r, c_)
                cell_.fill= fillc
                cell_.font= Font(color="000000")  # black text

    # auto-size + freeze
    for col in ws.columns:
        max_len=0
        letter= col[0].column_letter
        for cell in col:
            val= str(cell.value) if cell.value else ""
            max_len= max(max_len, len(val))
        ws.column_dimensions[letter].width= max_len+2
    ws.freeze_panes= "A2"

    # table
    if ws.max_row>1:
        last_r= ws.max_row
        last_c= ws.max_column
        ref= f"A1:{get_column_letter(last_c)}{last_r}"
        tb= Table(displayName="MismatchTable", ref=ref)
        style= TableStyleInfo(name="TableStyleMedium9", showRowStripes=True, showColumnStripes=False, showFirstColumn=True)
        tb.tableStyleInfo= style
        ws.add_table(tb)

    wb.save(out_path)
    logging.info(f"Mismatch => {out_path}")
    stamp= datetime.now().strftime("%Y%m%d_%H%M%S")
    stamped= out_path.parent/f"{out_path.stem}_{stamp}{out_path.suffix}"
    wb.save(stamped)
    logging.info(f"Timestamped => {stamped}")


# ----------------------------------------------------------------------------
# PDF => partial
# ----------------------------------------------------------------------------
class EnhancedPDFReport:
    def __init__(self, df_current: pd.DataFrame, df_history: pd.DataFrame, config: Dict):
        self.df_current= df_current
        self.df_history= df_history
        self.config= config
        self.page_count=0
        self.colors= {
            "primary":"#800020",
            "text":"#2C1810",
            "background":"#FFFFFF"
        }
        self.logo_path= self.config["paths"].get("LOGO_PATH","images/company_logo.png")

        self.PAGE_WIDTH= 8.5
        self.PAGE_HEIGHT= 11

    def generate(self)-> Path:
        stamp= datetime.now().strftime("%Y%m%d_%H%M%S")
        out_dir= Path("Reconciliation_pdf")
        out_dir.mkdir(parents=True, exist_ok=True)
        pdf_name= f"Reconciliation_{stamp}.pdf"
        pdf_path= out_dir/pdf_name
        with PdfPages(pdf_path) as pdf:
            self._cover_page(pdf)
            self._summary_page(pdf)
        logging.info(f"PDF => {pdf_path}")
        return pdf_path

    def _new_page(self)-> plt.Figure:
        fig= plt.figure(figsize=(self.PAGE_WIDTH,self.PAGE_HEIGHT))
        fig.patch.set_facecolor(self.colors["background"])
        plt.axis("off")
        self.page_count+=1

        # place small logo
        if self.logo_path and os.path.exists(self.logo_path):
            try:
                import matplotlib.image as mpimg
                img= mpimg.imread(self.logo_path)
                ax_img= fig.add_axes([0.65,0.75,0.3,0.2])
                ax_img.imshow(img, alpha=0.2)
                ax_img.axis("off")
            except:
                pass

        fig.text(0.5, 0.98, "Reconciliation Report", ha="center", fontsize=10, color="gray")
        fig.text(0.9, 0.03, f"Page {self.page_count}", ha="right", fontsize=8, color="gray")
        fig.text(0.5, 0.02, "Â© Ultra-Mega Reconciliation", ha="center", fontsize=8, color="gray")
        return fig

    def _cover_page(self, pdf: PdfPages):
        fig= self._new_page()
        plt.text(0.5,0.7,"Reconciliation Analysis Report",
                 ha="center",fontsize=24,fontweight="bold",color=self.colors["primary"],
                 transform=fig.transFigure)
        plt.text(0.5,0.6,f"Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                 ha="center",fontsize=12,color=self.colors["text"],
                 transform=fig.transFigure)
        plt.text(0.5,0.15,"CONFIDENTIAL",
                 ha="center",fontsize=9,color=self.colors["text"],
                 transform=fig.transFigure)
        pdf.savefig(fig)
        plt.close(fig)

    def _summary_page(self, pdf: PdfPages):
        fig= self._new_page()
        plt.text(0.5,0.92,"Summary",
                 ha="center",fontsize=18,fontweight="bold",color=self.colors["primary"],
                 transform=fig.transFigure)
        if self.df_current.empty:
            plt.text(0.5,0.75,"No mismatches found this run.",
                     ha="center",fontsize=14,color=self.colors["text"],
                     transform=fig.transFigure)
        else:
            total= len(self.df_current)
            c_mast= (self.df_current["Status"]=="Missing in Master").sum()
            c_erp=  (self.df_current["Status"]=="Missing in ERP").sum()
            c_diff= (self.df_current["Status"]=="Difference in both").sum()
            c_case= (self.df_current["Status"]=="CASE").sum()
            text= f"Total: {total}\nMissing in Master: {c_mast}\nMissing in ERP: {c_erp}\nDifference in both: {c_diff}\nCASE: {c_case}"
            plt.text(0.5,0.75,text, ha="center",fontsize=14,color=self.colors["text"],
                     transform=fig.transFigure)
        pdf.savefig(fig)
        plt.close(fig)


# ----------------------------------------------------------------------------
# HISTORY TAB
# ----------------------------------------------------------------------------
class HistoryTab(ctk.CTkFrame):
    def __init__(self, parent, hist_dir: Path):
        super().__init__(parent)
        self.history_dir= hist_dir
        self.tree= None
        self.build_ui()

    def build_ui(self):
        lbl= ctk.CTkLabel(self, text="Reconciliation Runs History", font=("Arial",16))
        lbl.pack(pady=5)
        self.tree= ttk.Treeview(self, columns=("Filename",), show="headings", height=15)
        self.tree.heading("Filename", text="History File")
        self.tree.pack(fill="both", expand=True, padx=10, pady=10)

        self.tree.bind("<Double-1>", self.on_double_click)

        ctk.CTkButton(self, text="Refresh", command=self.refresh_history,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(pady=5)
        self.refresh_history()

    def refresh_history(self):
        for i in self.tree.get_children():
            self.tree.delete(i)
        if not self.history_dir.is_dir():
            self.history_dir.mkdir(parents=True,exist_ok=True)
        files= sorted(self.history_dir.glob("run_*.json"), reverse=True)
        for f in files:
            self.tree.insert("", "end", values=(f.name,))

    def on_double_click(self, event):
        item_id= self.tree.focus()
        if not item_id:
            return
        fn= self.tree.item(item_id,"values")[0]
        if not fn:
            return
        path= self.history_dir/fn
        if not path.is_file():
            return
        try:
            with open(path,"r",encoding="utf-8") as ff:
                content= ff.read()
            pop= tk.Toplevel(self)
            pop.title(f"Viewing {fn}")
            txt= ctk.CTkTextbox(pop,width=800,height=600)
            txt.pack(fill="both",expand=True)
            txt.insert("end",content)
            txt.configure(state="disabled")
        except Exception as e:
            logging.error(f"HistoryTab doubleclick => {e}")


# ----------------------------------------------------------------------------
# ADVANCED DASHBOARD
# ----------------------------------------------------------------------------
class AdvancedDashboard(ctk.CTkFrame):
    def __init__(self, parent, config: Dict):
        super().__init__(parent)
        dash= config.get("dashboard",{})
        self.config= config
        self.selected_dims= set(dash.get("selected_dims",[]))
        self.selected_attrs= set(dash.get("selected_attrs",[]))
        self.top_n= dash.get("top_n",10)

        self.df_current= pd.DataFrame()
        self.df_history= pd.DataFrame()

        top= ctk.CTkScrollableFrame(self, orientation="horizontal", height=60)
        top.pack(fill="x", pady=5)
        self.metric_label= ctk.CTkLabel(top, text="Metrics: 0 mismatch, 0 dimension", width=300)
        self.metric_label.pack(side="left", padx=5)

        ctk.CTkButton(top,text="Filter Dimension",command=self.show_dim_filter,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)
        ctk.CTkButton(top,text="Filter Attribute",command=self.show_attr_filter,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)
        ctk.CTkButton(top,text="Toggle Top 10/All",command=self.toggle_top_n,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)

        self.main_frame= ctk.CTkFrame(self)
        self.main_frame.pack(fill="both",expand=True)

        # a tree to display data
        self.tree= ttk.Treeview(self.main_frame, show="headings")
        vsb= ttk.Scrollbar(self.main_frame, orient="vertical", command=self.tree.yview)
        hsb= ttk.Scrollbar(self.main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set,xscrollcommand=hsb.set)

        self.tree.grid(row=0,column=0,sticky="nsew")
        vsb.grid(row=0,column=1,sticky="ns")
        hsb.grid(row=1,column=0,sticky="ew")
        self.main_frame.rowconfigure(0,weight=1)
        self.main_frame.columnconfigure(0,weight=1)

    def toggle_top_n(self):
        if self.top_n==10:
            self.top_n=None
        else:
            self.top_n=10
        self.update_data_filters()

    def show_dim_filter(self):
        self.show_filter("Dimension")

    def show_attr_filter(self):
        self.show_filter("Attribute")

    def show_filter(self, col:str):
        base= self.df_history if not self.df_history.empty else self.df_current
        if base.empty or col not in base.columns:
            return
        pop= tk.Toplevel(self)
        pop.title(f"Filter: {col}")
        pop.geometry("300x400")

        fr= ctk.CTkFrame(pop)
        fr.pack(fill="both",expand=True,padx=5,pady=5)

        unq= base[col].dropna().unique()
        dsp_map={}
        for v in unq:
            dsp= str(v) if (isinstance(v,str) and v.strip()) else "(blank)"
            dsp_map[v]= dsp
        svals= sorted(dsp_map.keys(), key=lambda x:dsp_map[x].lower())

        if col=="Dimension":
            curr= self.selected_dims
        else:
            curr= self.selected_attrs
        if not curr:
            curr= set(svals)
        all_vals= set(svals)

        sel_all_var= tk.BooleanVar(value=(curr==all_vals or not curr))

        def toggle_all():
            c= sel_all_var.get()
            for vb in var_map.values():
                vb.set(c)

        ctk.CTkCheckBox(
            fr,text="Select All",variable=sel_all_var,command=toggle_all,
            fg_color="#800020",hover_color="#a52a2a",text_color="black"
        ).pack(anchor="w",pady=5)

        scr= ctk.CTkScrollableFrame(fr,width=250,height=250)
        scr.pack(fill="both",expand=True,padx=5,pady=5)
        var_map={}
        for v in svals:
            in_f= (v in curr) or (not curr)
            bvar= tk.BooleanVar(value=in_f)
            var_map[v]= bvar
            ctk.CTkCheckBox(
                scr,text=dsp_map[v],variable=bvar,
                fg_color="#800020",hover_color="#a52a2a",text_color="black"
            ).pack(anchor="w")

        def apply_():
            sel= {k for k,bv in var_map.items() if bv.get()}
            if col=="Dimension":
                self.selected_dims= sel
            else:
                self.selected_attrs= sel
            pop.destroy()
            self.update_data_filters()

        bf= ctk.CTkFrame(fr)
        bf.pack(fill="x",pady=5)
        ctk.CTkButton(bf,text="Apply",command=apply_,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)
        ctk.CTkButton(bf,text="Cancel",command=pop.destroy,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)

    def update_data(self, df_current: pd.DataFrame, df_history: pd.DataFrame):
        self.df_current= df_current.copy()
        self.df_history= df_history.copy()
        self.update_data_filters()

    def update_data_filters(self):
        dfc= self.df_current.copy()
        if not dfc.empty:
            if self.selected_dims:
                dfc= dfc[dfc["Dimension"].isin(self.selected_dims)]
            if self.selected_attrs:
                dfc= dfc[dfc["Attribute"].isin(self.selected_attrs)]
        mism= len(dfc)
        dims= dfc["Dimension"].nunique() if not dfc.empty and "Dimension" in dfc.columns else 0
        self.metric_label.configure(text=f"Mismatches: {mism}, Dims: {dims}")

        # show in tree
        for i in self.tree.get_children():
            self.tree.delete(i)
        if dfc.empty:
            self.tree["columns"]=[]
            return
        cols= list(dfc.columns)
        self.tree["columns"]= cols
        for c in cols:
            self.tree.heading(c,text=c,anchor="w")
            self.tree.column(c,anchor="w",width=150)
        for _,row in dfc.iterrows():
            rowvals= [row.get(c,"") for c in cols]
            self.tree.insert("", "end", values=rowvals)


# ----------------------------------------------------------------------------
# MAIN APP
# ----------------------------------------------------------------------------
class MainApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Ultra-Mega Reconciliation => Single Mismatch (Red), Full Dashboard, Name-first")
        self.geometry("1600x900")
        ctk.set_appearance_mode("light")

        self.config_dict= load_config(Path(DEFAULT_PATHS["CONFIG_PATH"]))
        self.param_dict= read_param_file(Path(self.config_dict["paths"].get("PARAMETER_PATH", DEFAULT_PATHS["PARAMETER_PATH"])))
        self.history_df= pd.DataFrame()

        self.tabs= ttk.Notebook(self)
        self.tabs.pack(fill="both", expand=True)

        # 1) Paths
        self.tab_paths= ctk.CTkFrame(self.tabs)
        self.build_paths_tab(self.tab_paths)
        self.tabs.add(self.tab_paths, text="Paths")

        # 2) ERP
        self.tab_erp= ctk.CTkFrame(self.tabs)
        efil= self.config_dict.get("erp_grid",{}).get("filters",{})
        self.erp_preview= SimplePreview(self.tab_erp,"ERP", efil)
        self.erp_preview.pack(fill="both",expand=True)
        self.tabs.add(self.tab_erp, text="ERP Preview")

        # 3) Master
        self.tab_master= ctk.CTkFrame(self.tabs)
        mfil= self.config_dict.get("master_grid",{}).get("filters",{})
        self.master_preview= SimplePreview(self.tab_master,"Master", mfil)
        self.master_preview.pack(fill="both",expand=True)
        self.tabs.add(self.tab_master, text="Master Preview")

        # 4) Compare
        self.tab_compare= ctk.CTkFrame(self.tabs)
        self.build_compare_tab(self.tab_compare)
        self.tabs.add(self.tab_compare, text="Compare")

        # 5) Dashboard
        self.dashboard_tab= AdvancedDashboard(self.tabs, self.config_dict)
        self.tabs.add(self.dashboard_tab, text="Dashboard")

        # 6) History
        histp= Path(self.config_dict["paths"].get("HISTORY_PATH","history_runs"))
        self.history_tab= HistoryTab(self.tabs, histp)
        self.tabs.add(self.history_tab, text="History")

        # Logging
        self.log_box= ctk.CTkTextbox(self, height=120)
        self.log_box.pack(fill="both", side="bottom")
        self.log_box.configure(state="disabled")
        handler= TextHandler(self.log_box)
        handler.setLevel(logging.INFO)
        logging.getLogger().addHandler(handler)

        # temp CSV
        self.temp_csv_dir= Path(self.config_dict["paths"].get("MASTER_CSV_OUTPUT","temp_master_csv"))
        self.temp_csv_dir.mkdir(parents=True, exist_ok=True)

        # load runs
        self.load_runs()

        # meltdown => show
        self.refresh_erp()
        self.refresh_master()
        self.dashboard_tab.update_data(pd.DataFrame(), self.history_df)

    def build_paths_tab(self, parent):
        frm= ctk.CTkFrame(parent)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        self.erp_var= tk.StringVar(value=self.config_dict["paths"].get("ERP_EXCEL_PATH", DEFAULT_PATHS["ERP_EXCEL_PATH"]))
        self.mast_var= tk.StringVar(value=self.config_dict["paths"].get("MASTER_ZIP_PATH", DEFAULT_PATHS["MASTER_ZIP_PATH"]))
        self.mast_folder_var= tk.StringVar(value=self.config_dict["paths"].get("MASTER_TXT_FOLDER",""))
        self.exc_var= tk.StringVar(value=self.config_dict["paths"].get("EXCEPTION_PATH", DEFAULT_PATHS["EXCEPTION_PATH"]))
        self.out_var= tk.StringVar(value=self.config_dict["paths"].get("OUTPUT_PATH", DEFAULT_PATHS["OUTPUT_PATH"]))
        self.par_var= tk.StringVar(value=self.config_dict["paths"].get("PARAMETER_PATH", DEFAULT_PATHS["PARAMETER_PATH"]))
        self.pdf_var= tk.StringVar(value=self.config_dict["paths"].get("PDF_EXPORT_PATH", DEFAULT_PATHS["PDF_EXPORT_PATH"]))

        def mkrow(lbl, var, is_dir=False):
            rowf= ctk.CTkFrame(frm)
            rowf.pack(fill="x", pady=5)
            ctk.CTkLabel(rowf,text=lbl,width=200).pack(side="left",padx=5)
            e= ctk.CTkEntry(rowf,textvariable=var,width=600)
            e.pack(side="left",padx=5)
            def br():
                if is_dir:
                    p= filedialog.askdirectory()
                else:
                    p= filedialog.askopenfilename()
                if p:
                    var.set(p)
            ctk.CTkButton(rowf,text="Browse",command=br,fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)

        mkrow("ERP Excel:", self.erp_var)
        mkrow("Master ZIP:", self.mast_var)
        mkrow("Master TXT Folder:", self.mast_folder_var, is_dir=True)
        mkrow("Exception Path:", self.exc_var)
        mkrow("Missing Items Output:", self.out_var)
        mkrow("Parameter File:", self.par_var)
        mkrow("PDF Export Path:", self.pdf_var)

        bf= ctk.CTkFrame(frm)
        bf.pack(fill="x", pady=10)
        ctk.CTkButton(bf,text="Save Config",command=self.save_config_all,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)
        ctk.CTkButton(bf,text="Refresh ERP",command=self.refresh_erp,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)
        ctk.CTkButton(bf,text="Refresh Master",command=self.refresh_master,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(side="left",padx=5)

    def build_compare_tab(self, parent):
        frm= ctk.CTkFrame(parent)
        frm.pack(fill="both", expand=True, padx=10, pady=10)
        ctk.CTkLabel(frm,text="Generate Mismatch Items",font=("Arial",16)).pack(pady=5)

        self.trim_key_var= tk.BooleanVar(value=self.config_dict.get("trim_key_toggle",False))
        ctk.CTkCheckBox(frm,text="Trim Key (remove spaces)?",variable=self.trim_key_var,
                        fg_color="#800020",hover_color="#a52a2a",text_color="black").pack(pady=5)

        ctk.CTkButton(frm,text="Run Reconciliation",command=self.run_compare,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(pady=10)

        ctk.CTkButton(frm,text="Export PDF",command=self.export_pdf,
                      fg_color="#800020",hover_color="#a52a2a",text_color="white").pack(pady=10)

    def load_runs(self):
        hpath= Path(self.config_dict["paths"].get("HISTORY_PATH","history_runs"))
        if not hpath.is_dir():
            return
        frames=[]
        for jf in hpath.glob("run_*.json"):
            try:
                dfj= pd.read_json(jf, orient="records")
                frames.append(dfj)
            except Exception as e:
                logging.error(f"History => {jf} => {e}")
        if frames:
            big= pd.concat(frames,ignore_index=True).drop_duplicates()
            if self.history_df.empty:
                self.history_df= big
            else:
                self.history_df= pd.concat([self.history_df,big],ignore_index=True).drop_duplicates()
            logging.info(f"Loaded runs => {len(self.history_df)} total records")

    def refresh_erp(self):
        ep= Path(self.erp_var.get().strip())
        df= read_erp_excel(ep)
        if df.empty:
            self.erp_preview.set_data(pd.DataFrame())
            return
        meltdown= meltdown_erp_for_preview(df, self.param_dict)
        pivoted= pivot_for_preview(meltdown)
        self.erp_preview.set_data(pivoted)

    def refresh_master(self):
        mf= self.mast_folder_var.get().strip()
        if mf:
            df_m= unify_master_txt_in_folder(Path(mf))
        else:
            zf= Path(self.mast_var.get().strip())
            outd= self.temp_csv_dir
            cfiles= convert_master_txt_to_csv(zf,outd)
            df_m= unify_master_csvs(cfiles)
        if df_m.empty:
            self.master_preview.set_data(pd.DataFrame())
            return
        meltdown= meltdown_master_for_preview(df_m, self.param_dict)
        pivoted= pivot_for_preview(meltdown)
        self.master_preview.set_data(pivoted)

    def run_compare(self):
        df_erp_w= self.erp_preview.get_filtered_df()
        df_mast_w= self.master_preview.get_filtered_df()

        e_long= meltdown_to_long(df_erp_w)
        m_long= meltdown_to_long(df_mast_w)

        trim_flag= bool(self.trim_key_var.get())
        mismatch_df= compare_name_attribute(e_long, m_long, trim_key=trim_flag)

        exc_path= Path(self.config_dict["paths"].get("EXCEPTION_PATH",""))
        df_exc= read_exception_table(exc_path)
        mismatch_df= merge_exceptions(mismatch_df, df_exc)

        outp= Path(self.out_var.get().strip())
        write_1sheet_excel(mismatch_df, outp)

        run_ts= datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        mismatch_df["RunDate"]= run_ts

        if self.history_df.empty:
            self.history_df= mismatch_df.copy()
        else:
            self.history_df= pd.concat([self.history_df,mismatch_df],ignore_index=True).drop_duplicates()

        histp= Path(self.config_dict["paths"].get("HISTORY_PATH","history_runs"))
        histp.mkdir(parents=True,exist_ok=True)
        run_file= histp/f"run_{run_ts.replace(':','-').replace(' ','_')}.json"
        try:
            mismatch_df.to_json(run_file, orient="records", indent=2)
            logging.info(f"Saved run => {run_file}")
        except Exception as e:
            logging.error(f"Error saving run => {e}")

        # update dash
        self.dashboard_tab.update_data(mismatch_df, self.history_df)
        self.history_tab.refresh_history()
        self.tabs.select(self.dashboard_tab)
        messagebox.showinfo("Done", f"Mismatch => {outp}")

    def export_pdf(self):
        if self.history_df.empty:
            messagebox.showinfo("PDF Export","No mismatch => history empty.")
            return
        if "RunDate" in self.history_df.columns:
            last_run= self.history_df["RunDate"].max()
            df_curr= self.history_df[self.history_df["RunDate"]== last_run].copy()
        else:
            df_curr= self.history_df.copy()

        rep= EnhancedPDFReport(df_curr, self.history_df, self.config_dict)
        pdfp= rep.generate()
        messagebox.showinfo("PDF Export", f"PDF => {pdfp}")

    def save_config_all(self):
        self.config_dict["paths"]["ERP_EXCEL_PATH"]= self.erp_var.get().strip()
        self.config_dict["paths"]["MASTER_ZIP_PATH"]= self.mast_var.get().strip()
        self.config_dict["paths"]["MASTER_TXT_FOLDER"]= self.mast_folder_var.get().strip()
        self.config_dict["paths"]["EXCEPTION_PATH"]= self.exc_var.get().strip()
        self.config_dict["paths"]["OUTPUT_PATH"]= self.out_var.get().strip()
        self.config_dict["paths"]["PARAMETER_PATH"]= self.par_var.get().strip()
        self.config_dict["paths"]["PDF_EXPORT_PATH"]= self.pdf_var.get().strip()

        self.config_dict["trim_key_toggle"]= bool(self.trim_key_var.get())

        self.config_dict.setdefault("erp_grid",{})
        self.config_dict["erp_grid"]["filters"]= self.erp_preview.filters

        self.config_dict.setdefault("master_grid",{})
        self.config_dict["master_grid"]["filters"]= self.master_preview.filters

        dash= self.config_dict.setdefault("dashboard",{})
        dash["selected_dims"]= list(self.dashboard_tab.selected_dims)
        dash["selected_attrs"]= list(self.dashboard_tab.selected_attrs)
        dash["top_n"]= self.dashboard_tab.top_n

        cfgp= Path(self.config_dict["paths"].get("CONFIG_PATH","config/ui_config.json"))
        save_config(self.config_dict, cfgp)


def main():
    app= MainApp()
    app.mainloop()

if __name__=="__main__":
    main()
