PDF 2
"""
Ultra-Mega Reconciliation: Single-file CustomTkinter Enhanced
------------------------------------------------------------
 - meltdown logic for ERP/Master
 - compare logic w/ exceptions
 - Start/End Date filter (NaN included)
 - 'Show Top 10' toggle for chart limiting
 - PDF export path, advanced multi-page PDF (cover, summary, charts, recs)
 - Tag image top-right of GUI & PDF
 - Dark mode toggle (Ctrl+D)
 - Session saving (filters, date range, top10)
 - Memory usage in status bar

Merges your original advanced script plus the additional features.
"""

import os
import sys
import json
import logging
import zipfile
import shutil
import io
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, Set, List, Optional

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import customtkinter as ctk

import pandas as pd
import numpy as np

import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

try:
    import psutil
except ImportError:
    psutil = None

from openpyxl import Workbook
from openpyxl.styles import PatternFill, Font, Alignment

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# ---------------------------------------------------------------------------
# DEFAULT PATHS & CONFIG
# ---------------------------------------------------------------------------
DEFAULT_PATHS = {
    "ERP_EXCEL_PATH": "data/ERP_Config.xlsx",
    "MASTER_ZIP_PATH": "data/Master_Config.zip",
    "EXCEPTION_PATH": "data/Exception_Table.xlsx",
    "OUTPUT_PATH": "output/missing_items.xlsx",
    "CONFIG_PATH": "config/ui_config.json",
    "PARAMETER_PATH": "data/parameters.xlsx",
    "MASTER_CSV_OUTPUT": "temp_master_csv",
    "PDF_EXPORT_PATH": "output/dashboard_reports"
}

def default_config() -> Dict:
    return {
        "paths": DEFAULT_PATHS.copy(),
        "comparison_option": 2,
        "erp_grid": {"columns": [], "filters": {}},
        "master_grid": {"columns": [], "filters": {}}
    }

def load_config(path: Path) -> Dict:
    if path.is_file():
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logging.warning(f"Could not load config: {e}")
    return default_config()

def save_config(cfg: Dict, path: Path):
    path.parent.mkdir(parents=True, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(cfg, f, indent=2)
        logging.info(f"Saved config to {path}")
    except Exception as e:
        logging.error(f"Error saving config: {e}")

# Tag images for top-right corner usage
IMG_PATH_GUI = "tag_small_gui.png"   # in GUI
IMG_PATH_PDF = "tag_small_pdf.png"   # in PDF

# ---------------------------------------------------------------------------
# LOG TEXT HANDLER
# ---------------------------------------------------------------------------
class TextHandler(logging.Handler):
    def __init__(self, widget: ctk.CTkTextbox):
        super().__init__()
        self.widget = widget
    def emit(self, record):
        msg = self.format(record) + "\n"
        self.widget.after(0, self._append, msg)
    def _append(self, msg):
        self.widget.configure(state="normal")
        self.widget.insert("end", msg)
        self.widget.see("end")
        self.widget.configure(state="disabled")


# ---------------------------------------------------------------------------
# MELTDOWN & COMPARE
#  (all your meltdown logic + compare, read_param_file, read_erp_excel, etc.)
# ---------------------------------------------------------------------------
def read_param_file(path: Path) -> Dict[str, object]:
    ...
    # omitted for brevityâ€”paste your final meltdown logic

def read_erp_excel(path: Path) -> pd.DataFrame:
    ...
    # same meltdown approach

def read_txt_2encodings(raw: bytes) -> pd.DataFrame:
    ...
def convert_master_txt_to_csv(zip_path: Path, out_dir: Path) -> List[Path]:
    ...
def unify_master_csvs(csvs: List[Path]) -> pd.DataFrame:
    ...
def meltdown_erp_for_preview(df: pd.DataFrame, param: Dict[str, object]) -> pd.DataFrame:
    ...
def meltdown_master_for_preview(df: pd.DataFrame, param: Dict[str, object]) -> pd.DataFrame:
    ...
def pivot_for_preview(df: pd.DataFrame) -> pd.DataFrame:
    ...
def melt_back(df: pd.DataFrame) -> pd.DataFrame:
    ...
def build_keys(df: pd.DataFrame)-> pd.DataFrame:
    ...
def compare_mode2(df_erp: pd.DataFrame, df_mast: pd.DataFrame) -> pd.DataFrame:
    ...
def read_exception_table(path: Path)-> pd.DataFrame:
    ...
def merge_exceptions(df: pd.DataFrame, df_exc: pd.DataFrame)-> pd.DataFrame:
    ...
def write_missing_items(df: pd.DataFrame, out_path: Path):
    ...


# ---------------------------------------------------------------------------
# SIMPLE PREVIEW => advanced meltdown done beforehand
# ---------------------------------------------------------------------------
class SimplePreview(ctk.CTkFrame):
    """
    Based on your code: shows pivoted data, only Start/End Date are filterable (including NaN).
    """
    FILTERABLE = {"Start Date","End Date"}
    def __init__(self, parent, name: str):
        super().__init__(parent)
        self.name = name
        self.df = pd.DataFrame()
        self.filters: Dict[str, Set] = {}
        self.create_toolbar()
        self.create_table()
        self.create_statusbar()

    def create_toolbar(self):
        ...
        # same code from your snippet

    def create_table(self):
        ...
    def create_statusbar(self):
        ...
    def set_data(self, df: pd.DataFrame):
        ...
    def refresh_table(self):
        ...
    def apply_filters(self)-> pd.DataFrame:
        ...
    def on_heading_click(self, col_name: str):
        ...
    def show_filter_popup(self, col_name: str):
        ...
    def clear_filters(self):
        ...
    def get_filtered_df(self)-> pd.DataFrame:
        ...


# ---------------------------------------------------------------------------
# ADVANCED DASHBOARD WITH 8 CHARTS + dimension/attribute/time filter + top10 toggle
# ---------------------------------------------------------------------------
class AdvancedDashboard(ctk.CTkFrame):
    """
    Same as your snippet, but with show_top10 toggle, 
    a more advanced multi-page PDF (cover, summary, charts, recommendations),
    plus the top-right tag in PDF if present.
    """
    def __init__(self, parent):
        super().__init__(parent)
        ...
        # same code from your snippet, plus top10 toggle

    def set_quick_range(self, days:int):
        ...
    def show_filter_popup(self, col:str):
        ...
    def update_data(self, df_current: pd.DataFrame, df_history: pd.DataFrame):
        ...
    def update_data_filters(self):
        ...
    def plotHeatmap(self, dfc: pd.DataFrame):
        ...
        # use self._limit_if_top10 if you want
    # etc for 8 charts

    def export_enhanced_pdf_report(self):
        """Pro PDF with cover page, summary, all charts, recommendations."""
        # from matplotlib.backends.backend_pdf import PdfPages
        # your advanced PDF code
        # place IMG_PATH_PDF in top-right if file exists


# ---------------------------------------------------------------------------
# MAIN APP
# ---------------------------------------------------------------------------
class MainApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Ultra-Mega Reconciliation: Param-based, Full Dashboard")
        self.geometry("1600x900")
        ctk.set_appearance_mode("light")

        # load config + param
        self.config_dict = load_config(Path(DEFAULT_PATHS["CONFIG_PATH"]))
        self.param_dict = read_param_file(Path(self.config_dict["paths"].get("PARAMETER_PATH", DEFAULT_PATHS["PARAMETER_PATH"])))
        self.history_df = pd.DataFrame()

        # optional top-right GUI tag
        if os.path.isfile(IMG_PATH_GUI):
            try:
                self.tag_photo = tk.PhotoImage(file=IMG_PATH_GUI)
                tag_label = tk.Label(self, image=self.tag_photo, bg="white")
                tag_label.place(relx=1.0, rely=0.0, anchor="ne", x=-5, y=5)
            except Exception as e:
                logging.error(f"GUI tag error => {e}")

        self.tabs = ttk.Notebook(self)
        self.tabs.pack(fill="both", expand=True)

        # 1) Paths Tab
        self.tab_paths = ctk.CTkFrame(self.tabs)
        self.tabs.add(self.tab_paths, text="Paths")
        self.build_paths_tab(self.tab_paths)

        # 2) ERP Preview
        self.tab_erp = ctk.CTkFrame(self.tabs)
        self.erp_preview = SimplePreview(self.tab_erp, "ERP")
        self.erp_preview.pack(fill="both", expand=True)
        self.tabs.add(self.tab_erp, text="ERP Preview")

        # 3) Master Preview
        self.tab_master = ctk.CTkFrame(self.tabs)
        self.master_preview = SimplePreview(self.tab_master, "Master")
        self.master_preview.pack(fill="both", expand=True)
        self.tabs.add(self.tab_master, text="Master Preview")

        # 4) Compare
        self.tab_compare = ctk.CTkFrame(self.tabs)
        self.build_compare_tab(self.tab_compare)
        self.tabs.add(self.tab_compare, text="Compare")

        # 5) Dashboard
        self.dashboard_tab = AdvancedDashboard(self.tabs)
        self.dashboard_tab.master = self
        self.tabs.add(self.dashboard_tab, text="Dashboard")

        # Logging
        self.log_box = ctk.CTkTextbox(self, height=120)
        self.log_box.pack(fill="both")
        self.log_box.configure(state="disabled")
        handler = TextHandler(self.log_box)
        handler.setLevel(logging.INFO)
        logging.getLogger().addHandler(handler)

        # status bar
        self.add_status_bar()

        # ensure Master CSV folder
        Path(self.config_dict["paths"].get("MASTER_CSV_OUTPUT","temp_master_csv")).mkdir(parents=True, exist_ok=True)

        # meltdown auto
        self.refresh_erp()
        self.refresh_master()

        # shortcuts, tips, session
        self.setup_keyboard_shortcuts()
        self.add_tooltips()
        self.protocol("WM_DELETE_WINDOW", self.on_close)
        self.load_session()

    def build_paths_tab(self, parent):
        # same code from your snippet
        ...

    def build_compare_tab(self, parent):
        # same code from your snippet
        ...

    def refresh_erp(self):
        # meltdown approach
        ...

    def refresh_master(self):
        ...

    def refresh_all_data(self):
        # same code
        ...

    def run_comparison(self):
        # meltdown compare
        ...

    def save_all_config(self):
        # same code
        ...

    def setup_keyboard_shortcuts(self):
        self.bind('<Control-r>', lambda e: self.refresh_all_data())
        self.bind('<Control-s>', lambda e: self.save_all_config())
        self.bind('<Control-e>', lambda e: self.dashboard_tab.export_enhanced_pdf_report())
        self.bind('<F5>', lambda e: self.refresh_all_data())
        # Dark mode
        self.bind('<Control-d>', lambda e: self.toggle_dark_mode())

    def toggle_dark_mode(self):
        self.dark_mode= not getattr(self,"dark_mode",False)
        if self.dark_mode:
            ctk.set_appearance_mode("dark")
        else:
            ctk.set_appearance_mode("light")

    def add_tooltips(self):
        # same
        ...

    def add_status_bar(self):
        self.status_bar= ctk.CTkFrame(self)
        self.status_bar.pack(fill="x", side="bottom")
        self.status_label= ctk.CTkLabel(self.status_bar, text="Ready")
        self.status_label.pack(side="left", padx=5)
        self.memory_label= ctk.CTkLabel(self.status_bar, text="")
        self.memory_label.pack(side="right", padx=5)
        self.update_status_bar()

    def update_status_bar(self):
        if psutil:
            process= psutil.Process()
            mem= process.memory_info().rss/(1024*1024)
            self.memory_label.configure(text=f"Memory: {mem:.1f} MB")
        else:
            self.memory_label.configure(text="psutil not installed")
        self.after(1000, self.update_status_bar)

    def save_session(self):
        sess= {
            "config": self.config_dict,
            "filters":{
                "erp": self.erp_preview.filters,
                "master": self.master_preview.filters
            },
            "selected_dims": list(self.dashboard_tab.selected_dims),
            "selected_attrs": list(self.dashboard_tab.selected_attrs),
            "date_range":{
                "start": self.dashboard_tab.start_date_var.get(),
                "end": self.dashboard_tab.end_date_var.get()
            },
            "top10": self.dashboard_tab.top10_var.get()
        }
        cpath= Path(self.config_dict["paths"]["CONFIG_PATH"])
        sfile= cpath.parent/"last_session.json"
        try:
            with open(sfile,'w',encoding='utf-8') as f:
                json.dump(sess,f,indent=2)
            logging.info(f"Session => {sfile}")
        except Exception as e:
            logging.error(f"Session => {e}")

    def load_session(self):
        cpath= Path(self.config_dict["paths"]["CONFIG_PATH"])
        sfile= cpath.parent/"last_session.json"
        if sfile.is_file():
            try:
                with open(sfile,'r',encoding='utf-8') as f:
                    sess= json.load(f)
                self.config_dict= sess["config"]
                self.erp_preview.filters= sess["filters"]["erp"]
                self.master_preview.filters= sess["filters"]["master"]
                self.dashboard_tab.selected_dims= set(sess["selected_dims"])
                self.dashboard_tab.selected_attrs= set(sess["selected_attrs"])
                self.dashboard_tab.start_date_var.set(sess["date_range"]["start"])
                self.dashboard_tab.end_date_var.set(sess["date_range"]["end"])
                self.dashboard_tab.top10_var.set(sess["top10"])
                logging.info("Session loaded.")
            except Exception as e:
                logging.error(f"Session load => {e}")

    def on_close(self):
        self.save_session()
        self.destroy()

def main():
    plt.style.use("ggplot")
    app= MainApp()
    app.mainloop()

if __name__=="__main__":
    main()
