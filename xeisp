"""
Script: Compare Master (Alfa) vs. xtreisp data across multiple sheets, apply exceptions,
        handle special "Canary" power-of-10 values in Alfa, add header borders,
        and export color-coded results to an existing OUTPUT.xlsx.

Author: Alex
Date: 2024-01-13
"""

import logging
import math
import pandas as pd
from openpyxl import load_workbook, Workbook
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import numbers  # For date formatting

# ----------------------------------------------------------------------------
# Configuration and Logging Setup
# ----------------------------------------------------------------------------

FILE_PATHS = {
    'master': a,
    'xtreisp': b,
    'exceptions': c,
    'output': d
}

SHEET_NAMES = {
    'master': 'Main',               # header=5 => row 6 are column titles in Alfa
    'xtreisp_sheets': [
        'xtreisp_Atlanta_1',
        'xtreisp_Libra',
        'xtreisp_Australia',
        'xtreisp_Canary',       # Canary sheet in xtreisp
        'xtreisp_Toby',
        'xtreisp_Submariner',
        'xtreisp_PolandSlovak'
    ],
    'exceptions': 'Treispe',
    'output_sheet': 'TREISPE OUTPUT'
}

SHEET_DIMENSION_MAPPING = {
    'xtreisp_Atlanta_1': 'Atlanta 1',
    'xtreisp_Libra': 'Libra',
    'xtreisp_Australia': 'Australia',
    'xtreisp_Canary': 'Canary',        # Dimension name for Canary
    'xtreisp_Toby': 'Toby',
    'xtreisp_Submariner': 'Submariner',
    'xtreisp_PolandSlovak': 'Poland Slovak'
}

# rename columns in the output as desired.
OUTPUT_COLUMN_MAPPING = {
    'DIM': 'Dimension',
    'V Master': 'Alfa Value',
    'Desc': 'Description',
    'End Date': 'End Date',
    'DIM xtreisp': 'Dimension xtreisp',
    'V xtreisp': 'xtreisp Value',
    'Status': 'Match Status',
    'Comment': 'Comments'
}

CANARY_REPLACEMENTS = {
    # "1E02": "CustomValue1",   
    # "1E03": "CustomValue2",   
    # add other replacements 
}

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# ----------------------------------------------------------------------------
# Helper Functions
# ----------------------------------------------------------------------------

def auto_fit_columns(ws, min_width=12, max_width=50):
    """
    Automatically adjusts the width of each column in the given worksheet based on the maximum length of the cell contents.
    Ensures that the column width is at least 'min_width' and does not exceed 'max_width'.
    """
    for col_cells in ws.columns:
        max_len = 0
        col_letter = get_column_letter(col_cells[0].column)
        for cell in col_cells:
            if cell.value is not None:
                try:
                    length = len(str(cell.value))
                    if length > max_len:
                        max_len = length
                except Exception as e:
                    logging.debug(f"Error measuring cell length: {e}")
        adjusted_width = max(max_len + 2, min_width)
        if adjusted_width > max_width:
            adjusted_width = max_width
        ws.column_dimensions[col_letter].width = adjusted_width

def handle_canary_power_of_ten(value: str) -> str:
    """
    For Alfa's Canary dimension only: if 'value' is strictly a power of 10
      (10, 100, 1000, 100000, etc.), convert to scientific notation like "1E02".
      If not, return the value as-is.
    """
    try:
        float_val = float(value)
        if float_val <= 0:
            return value
        log_val = math.log10(float_val)
        if abs(log_val - round(log_val)) < 1e-9:
            sci_str = f"{float_val:.0E}"
            sci_str = sci_str.replace("E+", "E")
            # Check if we need to manually replace
            if sci_str in CANARY_REPLACEMENTS:
                return CANARY_REPLACEMENTS[sci_str]
            return sci_str
        else:
            return value
    except ValueError:
        return value

def format_alfa_v3(name: str) -> str:
    """
    Applies specific formatting to dimension values when DIM == 'Atlanta 1'.
    Splits the string into [first char]-[second char]-[next 3 chars]-[remaining].
    Example: 'abc123' -> 'a-b-ABC-123'
    """
    if pd.notna(name):
        name = str(name)
        first = name[0] if len(name) > 0 else ""
        second = name[1] if len(name) > 1 else ""
        third = name[2:5] if len(name) > 2 else ""
        fourth = name[5:] if len(name) > 5 else ""
        formatted_name = f"{first}-{second}-{third.upper()}-{fourth.upper()}"
        if len(fourth) == 0 or fourth == "-":
            formatted_name = formatted_name[:-1]
        if len(fourth) == 2:
            return formatted_name
        return formatted_name.rstrip("-")
    return name

def read_master_file_filtered_v4(file_path: str, sheet_name: str, dimensions: list) -> pd.DataFrame:
    """
    Reads the master (Alfa) Excel file, filters rows by the given dimensions,
    and applies:
      - custom formatting for 'Atlanta 1'
      - power-of-10 logic for 'Canary'
    The file is read using specified columns (E:F,I,K) with header in row6.
    """
    logging.info(f"Reading master file from {file_path}, sheet: {sheet_name}")
    df_master = pd.read_excel(file_path, sheet_name=sheet_name, usecols="E:F,I,K", header=5, dtype=str)
    df_master.columns = ['DIM', 'V Master', 'Desc', 'End Date']
    df_master.dropna(how='all', inplace=True)
    
    mask_atlanta = df_master['DIM'] == 'Atlanta 1'
    df_master.loc[mask_atlanta, 'V Master'] = df_master.loc[mask_atlanta, 'V Master'].apply(format_alfa_v3)
    
    mask_canary = df_master['DIM'] == 'Canary'
    df_master.loc[mask_canary, 'V Master'] = df_master.loc[mask_canary, 'V Master'].apply(handle_canary_power_of_ten)
    
    try:
        df_master["End Date"] = pd.to_datetime(df_master["End Date"], errors='coerce')
    except Exception as e:
        logging.error(f"Error converting 'End Date': {e}")
    
    filtered_df = df_master[df_master['DIM'].isin(dimensions)]
    logging.info(f"Master file contains {len(filtered_df)} relevant records after filtering.")
    return filtered_df

def read_xtreisp_file_trimmed_v2(file_path: str, sheet_names: list, sheet_mapping: dict) -> pd.DataFrame:
    """
    Reads multiple xtreisp sheets.
    For each sheet, reads column A (using dtype=str to preserve raw strings such as leading zeros)
    starting from row 3 (i.e. skipping the first 2 rows) and assigns a dimension value based on
    the sheet_mapping.
    """
    logging.info(f"Reading xtreisp file from {file_path}")
    xls = pd.ExcelFile(file_path)
    output_data = []
    
    for sheet in sheet_names:
        if sheet in xls.sheet_names:
            logging.info(f"Processing sheet: {sheet}")
            df = pd.read_excel(xls, sheet_name=sheet, usecols="A", skiprows=2, header=None, dtype=str)
            df.columns = ['V xtreisp']
            # Do not strip so that raw strings (e.g., "00000") remain unchanged.
            df['DIM xtreisp'] = sheet_mapping[sheet]
            output_data.append(df)
        else:
            logging.warning(f"Sheet {sheet} not found in xtreisp file.")
    
    if output_data:
        concatenated_df = pd.concat(output_data, ignore_index=True)
        logging.info(f"xtreisp file contains {len(concatenated_df)} total records after processing.")
        return concatenated_df
    else:
        logging.error("No valid sheets found in xtreisp file.")
        return pd.DataFrame(columns=['DIM xtreisp', 'V xtreisp'])

def compare_data_v2(df_master: pd.DataFrame, df_xtreisp: pd.DataFrame) -> pd.DataFrame:
    """
    Merges Master vs. xtreisp on a combined key (DIM|V Master vs. DIM xtreisp|V xtreisp)
    to see matches or missing on either side.
    """
    logging.info("Comparing master and xtreisp data.")
    df_master['Concatenated_Alfa'] = df_master['DIM'].astype(str) + '|' + df_master['V Master'].astype(str)
    df_xtreisp['Concatenated_xtreisp'] = df_xtreisp['DIM xtreisp'].astype(str) + '|' + df_xtreisp['V xtreisp'].astype(str)
    
    merged_df = pd.merge(
        df_master,
        df_xtreisp,
        left_on='Concatenated_Alfa',
        right_on='Concatenated_xtreisp',
        how='outer',
        indicator=True
    )
    
    merged_df['Status'] = merged_df['_merge'].map({
        "both": "Match",
        "left_only": "Missing in xtreisp",
        "right_only": "Missing in Master"
    })
    merged_df.drop(columns=["_merge"], inplace=True)
    logging.info(f"Comparison completed with {len(merged_df)} records.")
    return merged_df

def read_exceptions_with_matching(file_path: str, sheet_name: str) -> pd.DataFrame:
    """
    Reads an Exceptions file, cleans column names, and keeps columns [D, V, ER].
    Builds a key = DIM + V to map comments later.
    """
    logging.info(f"Reading exceptions from {file_path}, sheet: {sheet_name}")
    exceptions_df = pd.read_excel(file_path, sheet_name=sheet_name)
    exceptions_df.columns = [col.replace(" ", "") for col in exceptions_df.columns]
    exceptions_df = exceptions_df[['D', 'V', 'ER']].copy()
    exceptions_df.columns = ['DIM', 'V', 'Comment']
    exceptions_df.dropna(subset=['DIM', 'V'], inplace=True)
    exceptions_df['DIM'] = exceptions_df['DIM'].astype(str).str.strip()
    exceptions_df['V'] = exceptions_df['V'].astype(str).str.strip()
    exceptions_df['Comment'] = exceptions_df['Comment'].astype(str).str.strip()
    exceptions_df['Key'] = exceptions_df['DIM'] + exceptions_df['V']
    logging.info(f"Exceptions file contains {len(exceptions_df)} records after cleaning.")
    return exceptions_df

def populate_comments_with_matching_v3(df: pd.DataFrame, exceptions_df: pd.DataFrame) -> pd.DataFrame:
    """
    Populates the 'Comments' column in the merged DataFrame based on matching keys
    from the exceptions DataFrame.
    """
    logging.info("Populating comments based on exceptions.")
    if 'Comment' not in df.columns:
        df['Comment'] = ""
    
    df['Key_x'] = df['DIM'] + df['V Master']
    df['Key_y'] = df['DIM xtreisp'] + df['V xtreisp']
    
    exception_dict = exceptions_df.set_index('Key')['Comment'].to_dict()
    
    df['Comment'] = df['Key_x'].map(exception_dict).fillna(
        df['Key_y'].map(exception_dict)
    ).fillna(df['Comment'])
    
    df.drop(['Key_x', 'Key_y'], axis=1, inplace=True)
    logging.info("Comments populated successfully.")
    return df

def write_to_existing_excel_with_custom_column_formatting(df: pd.DataFrame, output_path: str, sheet_name: str) -> None:
    """
    Writes the DataFrame to an existing Excel workbook, overwriting the specified sheet,
    applies custom formatting (colors, header borders) and auto-fits columns, then saves.
    The columns are renamed based on OUTPUT_COLUMN_MAPPING.
    """
    logging.info(f"Writing data to Excel file at {output_path}, sheet: {sheet_name}")
    
    try:
        wb = load_workbook(output_path)
        if sheet_name in wb.sheetnames:
            ws_to_remove = wb[sheet_name]
            wb.remove(ws_to_remove)
            logging.info(f"Removed existing sheet '{sheet_name}'.")
        ws = wb.create_sheet(sheet_name)
    except FileNotFoundError:
        logging.warning(f"Output file '{output_path}' does not exist. A new file will be created.")
        wb = Workbook()
        ws = wb.active
        ws.title = sheet_name
    
    # Rename the DataFrame columns as desired before writing.
    df.rename(columns=OUTPUT_COLUMN_MAPPING, inplace=True)
    
    rows = dataframe_to_rows(df, index=False, header=True)
    for r_idx, row_data in enumerate(rows, start=1):
        for c_idx, val in enumerate(row_data, start=1):
            ws.cell(row=r_idx, column=c_idx, value=val)
    
    # Define color fills and header border.
    header_fill = PatternFill(start_color="D9D9D9", end_color="D9D9D9", fill_type="solid")
    blue_fill = PatternFill(start_color="DDEBF7", end_color="DDEBF7", fill_type="solid")
    green_fill = PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid")
    yellow_fill = PatternFill(start_color="FFF2CC", end_color="FFF2CC", fill_type="solid")
    red_fill = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")
    white_fill = PatternFill(start_color="FFFFFF", end_color="FFFFFF", fill_type="solid")
    
    thin_side = Side(border_style="thin", color="000000")
    thin_border = Border(left=thin_side, right=thin_side, top=thin_side, bottom=thin_side)
    
    header_row = ws[1]
    for cell in header_row:
        cell.fill = header_fill
        cell.font = Font(bold=True)
        cell.alignment = Alignment(horizontal='center')
        cell.border = thin_border
    
    status_colors = {
        'Match': green_fill,
        'Missing in xtreisp': red_fill,
        'Missing in Master': red_fill
    }
    
    for row in ws.iter_rows(min_row=2):
        row[0].fill = green_fill     # Alfa Dimension
        row[1].fill = green_fill     # Alfa Value
        row[2].fill = blue_fill      # xtreisp Dimension
        row[3].fill = blue_fill      # xtreisp Value
        row[4].fill = yellow_fill    # End Date
        status_cell = row[5]
        fill_color = status_colors.get(status_cell.value, white_fill)
        status_cell.fill = fill_color
        row[6].fill = white_fill     # Comments
    
    auto_fit_columns(ws, min_width=12, max_width=50)
    
    try:
        wb.save(output_path)
        logging.info("Excel file updated successfully with custom formatting.")
    except Exception as e:
        logging.error(f"Error saving workbook '{output_path}': {e}")

# ----------------------------------------------------------------------------
# Main Code Execution
# ----------------------------------------------------------------------------

if __name__ == "__main__":
    try:
        # Read xtreisp file first TO obtain the dimensions available in xtreisp.
        df_xtreisp = read_xtreisp_file_trimmed_v2(FILE_PATHS['xtreisp'], SHEET_NAMES['xtreisp_sheets'], SHEET_DIMENSION_MAPPING)
        unique_xtreisp_dims = df_xtreisp['DIM xtreisp'].unique().tolist()
        logging.info(f"Unique dimensions in xtreisp: {unique_xtreisp_dims}")
        
        # Read Master file and filter by dimensions that exist in xtreisp.
        df_master = read_master_file_filtered_v4(FILE_PATHS['master'], SHEET_NAMES['master'], unique_xtreisp_dims)
        
        # Compare data based on the combined key.
        df_comparison = compare_data_v2(df_master, df_xtreisp)
        
        # Read exceptions and update comments.
        df_exceptions = read_exceptions_with_matching(FILE_PATHS['exceptions'], SHEET_NAMES['exceptions'])
        df_comparison = populate_comments_with_matching_v3(df_comparison, df_exceptions)
        
        # Write the comparison result to the OUTPUT file.
        write_to_existing_excel_with_custom_column_formatting(df_comparison, FILE_PATHS['output'], SHEET_NAMES['output_sheet'])
        
        logging.info("Process completed successfully.")
    except Exception as e:
        logging.error(f"Process terminated with error: {e}")
