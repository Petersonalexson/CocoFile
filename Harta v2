import openpyxl
from openpyxl.utils import get_column_letter

def main():
    """
    Main driver function.
    """

    # ----------------------------------------------------------------
    # 1) USER CONFIGURATIONS
    # ----------------------------------------------------------------
    # Paths to your files
    path_map_xlsx = r"C:\Path\to\MAP.xlsx"     # MAP file
    path_bani_xlsx = r"C:\Path\to\BANI.xlsx"   # BANI file

    # Sheet names
    map_sheet_name = "MAIN MAP"    # The sheet in MAP.xlsx
    xrp_sheet_name = "XRP"         # The sheet in BANI.xlsx containing transactions
    forecast_sheet_name = "Forcast"# The target sheet in BANI.xlsx to update

    # Column names (as they appear in the header or to search for) in MAP sheet
    map_col_account_header = "accounts"
    map_col_descriere_header = "Descriere 2"

    # Column names (as they appear in the header or to search for) in XRP sheet
    xrp_col_nat_cont_header = "nat cont"
    xrp_col_center_header   = "Center"
    xrp_col_quantitate_header = "Quantitate"

    # The forecast column title in the Forcast sheet where we need to put aggregated data
    # e.g. "Oct Actual" or something else. Make it easily configurable.
    forecast_column_header = "Oct Actual"

    # Optionally, if you have certain "Descriere 2" that map differently in the forecast:
    descriere_map_to_forecast = {
        # "Mercenari" : "Mercenari & Arnold",
        # "Antrnament": "Antrenament",
        # etc.
        #
        # If your descriptors match exactly in the forecast, you can leave it empty or minimal.
    }

    # ----------------------------------------------------------------
    # 2) READ the MAP workbook to build dictionary {account -> descriere}
    #    or {descriere -> [accounts]}, depending on your needs.
    #    For simplicity, let's store: allowed_accounts[acc] = descriere
    # ----------------------------------------------------------------
    map_wb = openpyxl.load_workbook(path_map_xlsx, data_only=True)
    map_ws = map_wb[map_sheet_name]

    # First, find which columns contain "accounts" and "Descriere 2"
    map_col_account_index = None
    map_col_descriere_index = None

    # Find the header row (assume the first row has headers)
    # If your file has multiple possible header rows, you can adapt.
    header_row = next(map_ws.iter_rows(min_row=1, max_row=1, values_only=True))
    for idx, col_value in enumerate(header_row, start=1):
        if col_value and col_value.strip().lower() == map_col_account_header.lower():
            map_col_account_index = idx
        elif col_value and col_value.strip().lower() == map_col_descriere_header.lower():
            map_col_descriere_index = idx

    if not map_col_account_index or not map_col_descriere_index:
        raise ValueError(
            f"Could not find columns '{map_col_account_header}' or "
            f"'{map_col_descriere_header}' in the MAP sheet's header."
        )

    # Build dictionary of allowed accounts -> descriere
    allowed_accounts = {}
    for row in map_ws.iter_rows(min_row=2, values_only=True):
        acc = row[map_col_account_index - 1]       # minus 1 because enumerate started at 1
        desc = row[map_col_descriere_index - 1]
        if acc and desc:
            allowed_accounts[acc] = str(desc).strip()

    map_wb.close()

    # ----------------------------------------------------------------
    # 3) READ the BANI -> XRP sheet to filter + aggregate
    #    aggregator[center][descriere] = sum of Quantitate
    # ----------------------------------------------------------------
    bani_wb = openpyxl.load_workbook(path_bani_xlsx)
    xrp_ws = bani_wb[xrp_sheet_name]

    # Identify column indexes for nat cont, center, quantitate
    xrp_header_row = next(xrp_ws.iter_rows(min_row=1, max_row=1, values_only=True))
    col_nat_cont_idx = None
    col_center_idx   = None
    col_quantitate_idx = None

    for idx, val in enumerate(xrp_header_row, start=1):
        if val and val.strip().lower() == xrp_col_nat_cont_header.lower():
            col_nat_cont_idx = idx
        elif val and val.strip().lower() == xrp_col_center_header.lower():
            col_center_idx = idx
        elif val and val.strip().lower() == xrp_col_quantitate_header.lower():
            col_quantitate_idx = idx

    if not col_nat_cont_idx or not col_center_idx or not col_quantitate_idx:
        raise ValueError(
            f"Could not find columns '{xrp_col_nat_cont_header}', '{xrp_col_center_header}', "
            f"or '{xrp_col_quantitate_header}' in the XRP sheet's header."
        )

    # aggregator[center][descriere] = total_sum
    aggregator = {}

    # Iterate over rows in XRP, ignoring the first (header)
    for row in xrp_ws.iter_rows(min_row=2, values_only=True):
        nat_cont  = row[col_nat_cont_idx - 1]
        center    = row[col_center_idx - 1]
        quantitate= row[col_quantitate_idx - 1]

        # Filter only if nat_cont is in allowed_accounts
        if nat_cont in allowed_accounts and center is not None and quantitate is not None:
            descriere = allowed_accounts[nat_cont]
            # aggregator by center => by descriere
            if center not in aggregator:
                aggregator[center] = {}
            if descriere not in aggregator[center]:
                aggregator[center][descriere] = 0
            aggregator[center][descriere] += quantitate

    # ----------------------------------------------------------------
    # 4) WRITE to the Forcast sheet.
    #    We need to find each center, find forecast_column_header column,
    #    then for each row under that center (e.g., "Plata", "Mercenari & Arnold", etc.),
    #    we put the aggregated value.
    # ----------------------------------------------------------------
    forecast_ws = bani_wb[forecast_sheet_name]

    # To find the column with the text "Oct Actual" (or user chosen)
    # we will scan each row (often row 1 or so), or search *all rows*
    # because the layout might be scattered. We'll store the column index
    # if we find a cell with exactly forecast_column_header.

    # For complicated layouts, you might want a more robust approach,
    # but here's a straightforward search:
    forecast_column_idx = None
    for row in forecast_ws.iter_rows(values_only=False):
        for cell in row:
            if cell.value and str(cell.value).strip().lower() == forecast_column_header.lower():
                forecast_column_idx = cell.column  # 1-based integer index
                break
        if forecast_column_idx:
            break

    if not forecast_column_idx:
        raise ValueError(
            f"Could not find a cell with value '{forecast_column_header}' in Forcast sheet."
        )

    # Helper function: find a cell containing `value` in entire sheet. Return row index or None.
    def find_row_with_value(sheet, value, start_row=1):
        """
        Search from start_row downward for a cell whose value matches `value` exactly.
        Returns the 1-based row index if found, else None.
        """
        for r in range(start_row, sheet.max_row + 1):
            cell_val = sheet.cell(row=r, column=1).value  # searching in first column, if that's how "Center" is stored
            # If your layout is more complex, you can check multiple columns or the entire row
            # but let's assume the 'Center' label is in column A.
            if cell_val is not None and str(cell_val).strip() == str(value):
                return r
        return None

    # Another helper: find the row that has the text for "Descriere" in the first column (or wherever).
    # We'll do a simple version that checks column A as well, just below the center row.
    # But you might want a more flexible approach if the row can appear anywhere below center.
    def find_row_for_descriere_after_center(sheet, start_row, descriere_text, max_search=50):
        """
        Starting from the row after `start_row`, look up to `max_search` rows below,
        for a cell in column A matching `descriere_text`. Return row index or None.
        """
        for r in range(start_row+1, min(start_row+1+max_search, sheet.max_row+1)):
            cell_val = sheet.cell(row=r, column=1).value
            if cell_val is not None and str(cell_val).strip().lower() == descriere_text.lower():
                return r
        return None

    # Now we iterate over each center in aggregator, search for it in forecast sheet, then update each descriere
    for center, descriere_dict in aggregator.items():
        # 1) find center row
        center_row = find_row_with_value(forecast_ws, center)
        if center_row is None:
            # If no row was found for that center, skip
            continue

        # 2) for each descriere in this center
        for descriere, total_val in descriere_dict.items():
            # If there's a special mapping needed (e.g. "Mercenari" => "Mercenari & Arnold"), do it:
            final_descriere = descriere_map_to_forecast.get(descriere, descriere)

            # 3) find the row for that descriere (some lines below center_row)
            descriere_row = find_row_for_descriere_after_center(forecast_ws, center_row, final_descriere)
            if descriere_row is None:
                # skip if not found in layout
                continue

            # 4) Write the aggregated total into the forecast_column_idx for that row
            forecast_ws.cell(row=descriere_row, column=forecast_column_idx, value=total_val)

    # ----------------------------------------------------------------
    # 5) Save changes
    # ----------------------------------------------------------------
    bani_wb.save(path_bani_xlsx)
    bani_wb.close()

    print("Done! The data has been aggregated and updated in the Forcast sheet.")


if __name__ == "__main__":
    main()
