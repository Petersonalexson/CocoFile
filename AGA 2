# AGA 2
"""
Ultra-Mega Reconciliation (Single-File):
 - meltdown logic (ERP & Master)
 - compare logic, exceptions
 - Start/End Date filter (including NaN) in previews
 - Dashboard with dimension/attribute/time filter
   * Also filters historical runs by the same date range
 - Show Top 10 toggle in the Dashboard
 - PDF export with cover + each chart
 - Keyboard shortcuts (Ctrl+R, Ctrl+S, Ctrl+E, F5)
 - Session management
 - Memory usage in status bar
"""

import os
import sys
import json
import logging
import zipfile
import shutil
import io
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, Set, List

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import customtkinter as ctk

import pandas as pd
import numpy as np

import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

try:
    import chardet
except ImportError:
    chardet = None

try:
    import psutil
except ImportError:
    psutil = None

from openpyxl import Workbook
from openpyxl.styles import PatternFill, Font, Alignment

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# ---------------------------------------------------------------------------
# DEFAULT CONFIG
# ---------------------------------------------------------------------------
DEFAULT_PATHS = {
    "ERP_EXCEL_PATH": "data/ERP_Config.xlsx",
    "MASTER_ZIP_PATH": "data/Master_Config.zip",
    "EXCEPTION_PATH": "data/Exception_Table.xlsx",
    "OUTPUT_PATH": "output/missing_items.xlsx",
    "CONFIG_PATH": "config/ui_config.json",
    "PARAMETER_PATH": "data/parameters.xlsx",
    "MASTER_CSV_OUTPUT": "temp_master_csv",
    "PDF_EXPORT_PATH": "output/dashboard_reports"
}

def default_config() -> Dict:
    return {
        "paths": DEFAULT_PATHS.copy(),
        "comparison_option": 2,
        "erp_grid": {"columns": [], "filters": {}},
        "master_grid": {"columns": [], "filters": {}}
    }

def load_config(path: Path) -> Dict:
    if path.is_file():
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logging.warning(f"Could not load config: {e}")
    return default_config()

def save_config(cfg: Dict, path: Path):
    path.parent.mkdir(parents=True, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(cfg, f, indent=2)
        logging.info(f"Saved config to {path}")
    except Exception as e:
        logging.error(f"Error saving config: {e}")

# ---------------------------------------------------------------------------
# LOG TEXT HANDLER
# ---------------------------------------------------------------------------
class TextHandler(logging.Handler):
    def __init__(self, widget: ctk.CTkTextbox):
        super().__init__()
        self.widget = widget
    def emit(self, record):
        msg = self.format(record) + "\n"
        self.widget.after(0, self._append, msg)
    def _append(self, msg):
        self.widget.configure(state="normal")
        self.widget.insert("end", msg)
        self.widget.see("end")
        self.widget.configure(state="disabled")

# ---------------------------------------------------------------------------
# READ PARAM FILE
# ---------------------------------------------------------------------------
def read_param_file(path: Path) -> Dict[str, object]:
    param = {
        "dim_erp_keep": set(),
        "dim_erp_map": {},
        "dim_master_map": {},
        "attr_erp_map": {},
        "attr_master_map": {}
    }
    if not path.is_file():
        logging.warning(f"Param file not found => {path}")
        return param
    try:
        dim_df = pd.read_excel(path, sheet_name="Dimension Parameters")
        dim_df.columns = dim_df.columns.astype(str).str.strip()

        def s(x): return str(x).strip() if pd.notna(x) else ""
        for _, row in dim_df.iterrows():
            fn = s(row.get("FileName",""))
            vsc= s(row.get("V S C",""))
            dim= s(row.get("Dimension",""))
            ev = s(row.get("ERP Values",""))
            if ev.lower()=="x" and vsc and dim:
                param["dim_erp_keep"].add(vsc)
            if vsc and dim:
                param["dim_erp_map"][vsc] = dim
            if fn and dim and ev.lower()=="x":
                param["dim_master_map"][fn] = dim

        attr_df = pd.read_excel(path, sheet_name="Attribute Parameters")
        attr_df.columns = attr_df.columns.astype(str).str.strip()
        for _, row in attr_df.iterrows():
            e_orig = s(row.get("ERP Original Attributes",""))
            m_orig = s(row.get("Master Original Attributes",""))
            final_ = s(row.get("Attribute",""))
            onoff = s(row.get("On/Off",""))
            if onoff.lower()=="x" and final_:
                if e_orig:
                    param["attr_erp_map"][e_orig] = final_
                if m_orig:
                    param["attr_master_map"][m_orig] = final_
        return param
    except Exception as e:
        logging.error(f"Error reading param file => {e}")
        return param

# ---------------------------------------------------------------------------
# ERP
# ---------------------------------------------------------------------------
def read_erp_excel(path: Path) -> pd.DataFrame:
    if not path.is_file():
        logging.warning(f"ERP Excel not found => {path}")
        return pd.DataFrame()
    try:
        df = pd.read_excel(path, skiprows=3)
        df.columns = df.columns.str.strip()
        if "Enabled_Flag" in df.columns:
            df = df[df["Enabled_Flag"]=="Enabled"]
        return df
    except Exception as e:
        logging.error(f"Error reading ERP => {e}")
        return pd.DataFrame()

# ---------------------------------------------------------------------------
# MASTER => .txt => unify
# ---------------------------------------------------------------------------
def read_txt_2encodings(raw: bytes) -> pd.DataFrame:
    for enc in ["utf-8-sig","utf-16-le"]:
        try:
            buf = io.BytesIO(raw)
            df = pd.read_csv(buf, encoding=enc, on_bad_lines="skip", engine="python")
            df.dropna(how="all", axis=0, inplace=True)
            df.dropna(how="all", axis=1, inplace=True)
            df.columns = df.columns.astype(str).str.strip()
            logging.info(f"[read_txt_2encodings] success with {enc}, shape={df.shape}")
            return df
        except Exception as e:
            logging.debug(f"[read_txt_2encodings] fail with {enc} => {e}")
    logging.error("[read_txt_2encodings] cannot parse .txt => empty.")
    return pd.DataFrame()

def convert_master_txt_to_csv(zip_path: Path, out_dir: Path) -> List[Path]:
    if not zip_path.is_file():
        logging.warning(f"[Master] ZIP not found => {zip_path}")
        return []
    if out_dir.exists():
        shutil.rmtree(out_dir, ignore_errors=True)
    out_dir.mkdir(parents=True, exist_ok=True)
    csvs = []
    with zipfile.ZipFile(zip_path,"r") as z:
        txt_files= [f for f in z.namelist() if f.lower().endswith(".txt")]
        for txt_file in txt_files:
            base_name = os.path.basename(txt_file)
            if not base_name:
                continue
            try:
                with z.open(txt_file) as fo:
                    raw = fo.read()
                df = read_txt_2encodings(raw)
                if df.empty:
                    continue
                df["RawFileName"] = base_name
                if "Name" not in df.columns and len(df.columns)>0:
                    first_col= df.columns[0]
                    df.rename(columns={first_col:"Name"}, inplace=True)
                out_csv = out_dir / (base_name.replace(".txt",".csv"))
                df.to_csv(out_csv, index=False, encoding="utf-8")
                csvs.append(out_csv)
            except Exception as e:
                logging.error(f"[Master] error reading {txt_file} => {e}")
    return csvs

def unify_master_csvs(csvs: List[Path]) -> pd.DataFrame:
    frames=[]
    for cp in csvs:
        if not cp.is_file():
            continue
        try:
            df = pd.read_csv(cp, encoding="utf-8", on_bad_lines="skip")
            df.columns = df.columns.str.strip()
            frames.append(df)
        except Exception as e:
            logging.error(f"[unify_master_csvs] reading {cp} => {e}")
    if frames:
        return pd.concat(frames, ignore_index=True)
    return pd.DataFrame()

# ---------------------------------------------------------------------------
# MELTDOWN
# ---------------------------------------------------------------------------
def meltdown_erp_for_preview(df: pd.DataFrame, param: Dict[str, object]) -> pd.DataFrame:
    ...
def meltdown_master_for_preview(df: pd.DataFrame, param: Dict[str, object]) -> pd.DataFrame:
    ...
def pivot_for_preview(df: pd.DataFrame) -> pd.DataFrame:
    ...

# ---------------------------------------------------------------------------
# COMPARE => meltdown => missing
# ---------------------------------------------------------------------------
def melt_back(df: pd.DataFrame) -> pd.DataFrame:
    ...
def build_keys(df: pd.DataFrame)-> pd.DataFrame:
    ...
def compare_mode2(df_erp: pd.DataFrame, df_mst: pd.DataFrame) -> pd.DataFrame:
    ...
def read_exception_table(path: Path)-> pd.DataFrame:
    ...
def merge_exceptions(df: pd.DataFrame, df_exc: pd.DataFrame)-> pd.DataFrame:
    ...
def write_missing_items(df: pd.DataFrame, out_path: Path):
    ...

# ---------------------------------------------------------------------------
# PREVIEW CLASS (ERP & MASTER)
# ---------------------------------------------------------------------------
class SimplePreview(ctk.CTkFrame):
    FILTERABLE = {"Start Date","End Date"}
    def __init__(self, parent, name: str):
        super().__init__(parent)
        self.name = name
        self.df = pd.DataFrame()
        self.filters: Dict[str, Set] = {}
        self.create_toolbar()
        self.create_table()
        self.create_statusbar()

    def create_toolbar(self):
        bar= ctk.CTkFrame(self, corner_radius=10, fg_color="#f0f0f0")
        bar.pack(fill="x", padx=5, pady=5)
        ctk.CTkLabel(bar, text=f"{self.name} Preview", fg_color="#800020", text_color="white", corner_radius=8).pack(side="left", padx=5)
        ctk.CTkButton(bar, text="ⓘ", width=30, command=self.show_info,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)
        ctk.CTkButton(bar, text="Clear Date Filters", command=self.clear_filters,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)

    def show_info(self):
        messagebox.showinfo("Info", f"{self.name} data after meltdown.\nStart/End Date columns filterable (NaN included).")

    def create_table(self):
        container = ctk.CTkFrame(self)
        container.pack(fill="both", expand=True, padx=5, pady=5)
        self.tree = ttk.Treeview(container, show="headings")
        vsb = ttk.Scrollbar(container, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(container, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        self.tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")
        container.rowconfigure(0, weight=1)
        container.columnconfigure(0, weight=1)

    def create_statusbar(self):
        self.status_label = ctk.CTkLabel(self, text="0 rows")
        self.status_label.pack(fill="x")

    def set_data(self, df: pd.DataFrame):
        self.filters.clear()
        self.df = df.copy()
        self.refresh_table()

    def refresh_table(self):
        for i in self.tree.get_children():
            self.tree.delete(i)
        if self.df.empty:
            self.tree["columns"]= []
            self.status_label.configure(text="0 rows")
            return
        cols = list(self.df.columns)
        self.tree["columns"] = cols
        for c in cols:
            self.tree.heading(c, text=c, anchor="w",
                              command=lambda col=c:self.on_heading_click(col))
            self.tree.column(c, anchor="w", width=150)
        df_f = self.apply_filters()
        for _, row in df_f.iterrows():
            rowvals = [row[c] for c in cols]
            self.tree.insert("", "end", values=rowvals)
        self.status_label.configure(text=f"{len(df_f)} rows")

    def apply_filters(self)-> pd.DataFrame:
        df_f = self.df.copy()
        for col, allowed in self.filters.items():
            if col in df_f.columns:
                df_f = df_f[df_f[col].isin(allowed)]
        return df_f

    def on_heading_click(self, col_name: str):
        if col_name in self.FILTERABLE:
            self.show_filter_popup(col_name)

    def show_filter_popup(self, col_name: str):
        if self.df.empty or col_name not in self.df.columns:
            return
        popup= tk.Toplevel(self)
        popup.title(f"Filter: {col_name}")
        popup.geometry("300x400")
        frame= ctk.CTkFrame(popup)
        frame.pack(fill="both", expand=True, padx=5, pady=5)

        unique_vals= self.df[col_name].unique()
        display_map={}
        for v in unique_vals:
            if pd.isna(v):
                dsp= "(NaN)"
            elif isinstance(v,str) and not v.strip():
                dsp= "(blank)"
            else:
                dsp= str(v)
            display_map[v]= dsp
        sorted_vals= sorted(display_map.keys(), key=lambda x: display_map[x].lower())
        curr_filter= self.filters.get(col_name, set(unique_vals))

        selall_var= tk.BooleanVar(value=True)
        def toggle_all():
            check= selall_var.get()
            for key2, vb in var_dict.items():
                vb.set(check)

        ctk.CTkCheckBox(frame, text="Select All", variable=selall_var, command=toggle_all,
                        fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(anchor="w", pady=5)

        scroll= ctk.CTkScrollableFrame(frame, width=250, height=250)
        scroll.pack(fill="both", expand=True, padx=5, pady=5)
        var_dict={}
        for rv in sorted_vals:
            in_filter= rv in curr_filter
            bvar= tk.BooleanVar(value=in_filter)
            var_dict[rv]= bvar
            dsp2= display_map[rv]
            ctk.CTkCheckBox(scroll, text=dsp2, variable=bvar,
                            fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(anchor="w")

        def apply_():
            sel = {rv for rv,vb in var_dict.items() if vb.get()}
            if sel == set(sorted_vals) or not sel:
                self.filters.pop(col_name,None)
            else:
                self.filters[col_name] = sel
            popup.destroy()
            self.refresh_table()

        bf= ctk.CTkFrame(frame)
        bf.pack(fill="x", pady=5)
        ctk.CTkButton(bf, text="Apply", command=apply_,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)
        ctk.CTkButton(bf, text="Cancel", command=popup.destroy,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)

    def clear_filters(self):
        self.filters.clear()
        self.refresh_table()

    def get_filtered_df(self)-> pd.DataFrame:
        return self.apply_filters()

# ---------------------------------------------------------------------------
# ADVANCED DASHBOARD with date filter for both current & history
# ---------------------------------------------------------------------------
class AdvancedDashboard(ctk.CTkFrame):
    def __init__(self, parent):
        super().__init__(parent)
        self.df_current = pd.DataFrame()
        self.df_history = pd.DataFrame()
        self.selected_dims: Set[str] = set()
        self.selected_attrs: Set[str] = set()
        self.show_top10_var= tk.BooleanVar(value=False)

        topbar = ctk.CTkFrame(self, corner_radius=10, fg_color="#f0f0f0")
        topbar.pack(fill="x", padx=5, pady=5)

        self.metric_label = ctk.CTkLabel(topbar, text="Metrics: 0 missing, 0 dimension", width=300)
        self.metric_label.pack(side="left", padx=5)

        ctk.CTkButton(topbar, text="Filter Dimension", command=self.show_dimension_filter,
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)
        ctk.CTkButton(topbar, text="Filter Attribute", command=self.show_attribute_filter,
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)

        # Show Top 10
        ctk.CTkCheckBox(
            topbar, text="Show Top 10",
            variable=self.show_top10_var,
            fg_color="#800020", text_color="white",
            hover_color="#a52a2a",
            command=self.update_data_filters
        ).pack(side="left", padx=5)

        # Quick date filter
        ctk.CTkButton(topbar, text="Last 7 Days", command=lambda: self.set_quick_range(7),
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)
        ctk.CTkButton(topbar, text="Last 30 Days", command=lambda: self.set_quick_range(30),
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)
        ctk.CTkButton(topbar, text="Last 90 Days", command=lambda: self.set_quick_range(90),
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)
        ctk.CTkButton(topbar, text="All Time", command=lambda: self.set_quick_range(9999),
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)

        self.start_date_var = tk.StringVar(value=(datetime.now()-timedelta(days=30)).strftime("%Y-%m-%d"))
        self.end_date_var = tk.StringVar(value=datetime.now().strftime("%Y-%m-%d"))

        ctk.CTkEntry(topbar, textvariable=self.start_date_var, width=100).pack(side="left", padx=5)
        ctk.CTkEntry(topbar, textvariable=self.end_date_var, width=100).pack(side="left", padx=5)

        ctk.CTkButton(topbar, text="Update Timeline", command=self.update_data_filters,
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)

        ctk.CTkButton(topbar, text="Export PDF", command=self.export_dashboard_pdf,
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)

        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill="both", expand=True)
        self.frames = {}
        chart_names = ["Heatmap","Lollipop","Circular","Scatter","Radar","Normal Pie","Normal Bar","Band Chart"]
        for lbl in chart_names:
            fr = ctk.CTkFrame(self.notebook)
            self.notebook.add(fr, text=lbl)
            self.frames[lbl] = fr

    def set_quick_range(self, days: int):
        if days>9000:
            self.start_date_var.set("1900-01-01")
            self.end_date_var.set("2100-12-31")
        else:
            dt_end = datetime.now()
            dt_start = dt_end - timedelta(days=days)
            self.start_date_var.set(dt_start.strftime("%Y-%m-%d"))
            self.end_date_var.set(dt_end.strftime("%Y-%m-%d"))
        self.update_data_filters()

    def show_dimension_filter(self):
        self.show_filter_popup("Dimension")

    def show_attribute_filter(self):
        self.show_filter_popup("Attribute")

    def show_filter_popup(self, col: str):
        base_df = self.df_history if not self.df_history.empty else self.df_current
        if base_df.empty or col not in base_df.columns:
            return
        popup = tk.Toplevel(self)
        popup.title(f"Filter: {col}")
        popup.geometry("300x400")
        frame= ctk.CTkFrame(popup)
        frame.pack(fill="both", expand=True, padx=5, pady=5)

        unique_vals= base_df[col].unique()
        display_map={}
        for v in unique_vals:
            if pd.isna(v):
                dsp= "(NaN)"
            elif isinstance(v,str) and not v.strip():
                dsp= "(blank)"
            else:
                dsp= str(v)
            display_map[v]= dsp
        sorted_vals= sorted(display_map.keys(), key=lambda x: display_map[x].lower())

        if col=="Dimension":
            curr = self.selected_dims
        else:
            curr = self.selected_attrs

        if not curr:
            curr = set(unique_vals)

        selall_var= tk.BooleanVar(value=True)
        def toggle_all():
            check= selall_var.get()
            for key2, vb in var_dict.items():
                vb.set(check)

        ctk.CTkCheckBox(frame, text="Select All", variable=selall_var, command=toggle_all,
                        fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(anchor="w", pady=5)

        scroll= ctk.CTkScrollableFrame(frame, width=250, height=250)
        scroll.pack(fill="both", expand=True, padx=5, pady=5)
        var_dict={}
        for rv in sorted_vals:
            in_filter= rv in curr
            bvar= tk.BooleanVar(value=in_filter)
            var_dict[rv]= bvar
            ctk.CTkCheckBox(scroll, text=display_map[rv], variable=bvar,
                            fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(anchor="w")

        def apply_():
            sel= {rv for rv,vb in var_dict.items() if vb.get()}
            if col=="Dimension":
                self.selected_dims = sel
            else:
                self.selected_attrs = sel
            popup.destroy()
            self.update_data_filters()

        bf= ctk.CTkFrame(frame)
        bf.pack(fill="x", pady=5)
        ctk.CTkButton(bf, text="Apply", command=apply_,
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)
        ctk.CTkButton(bf, text="Cancel", command=popup.destroy,
                      fg_color="#800020", text_color="white", hover_color="#a52a2a").pack(side="left", padx=5)

    def update_data(self, df_current: pd.DataFrame, df_history: pd.DataFrame):
        self.df_current = df_current.copy()
        self.df_history = df_history.copy()
        self.update_data_filters()

    def update_data_filters(self):
        """Apply dimension, attribute, date filters to both self.df_current and self.df_history."""
        dfc = self.df_current.copy()
        dfh = self.df_history.copy()

        # 1) dimension / attribute
        if not dfc.empty:
            if self.selected_dims:
                dfc = dfc[dfc["Dimension"].isin(self.selected_dims)]
            if self.selected_attrs:
                dfc = dfc[dfc["Attribute"].isin(self.selected_attrs)]
        if not dfh.empty:
            if self.selected_dims:
                dfh = dfh[dfh["Dimension"].isin(self.selected_dims)]
            if self.selected_attrs:
                dfh = dfh[dfh["Attribute"].isin(self.selected_attrs)]

        # 2) date range => both dfc & dfh
        try:
            s_ = datetime.strptime(self.start_date_var.get(), "%Y-%m-%d")
            e_ = datetime.strptime(self.end_date_var.get(), "%Y-%m-%d")
        except:
            logging.error("Invalid date range => ignoring.")
            s_ = datetime(1900,1,1)
            e_ = datetime(2100,12,31)

        if not dfc.empty and "RunDate" in dfc.columns:
            dfc["RunDate_dt"] = pd.to_datetime(dfc["RunDate"], errors="coerce")
            dfc = dfc[(dfc["RunDate_dt"]>= s_) & (dfc["RunDate_dt"]<= e_)]
        if not dfh.empty and "RunDate" in dfh.columns:
            dfh["RunDate_dt"] = pd.to_datetime(dfh["RunDate"], errors="coerce")
            dfh = dfh[(dfh["RunDate_dt"]>= s_) & (dfh["RunDate_dt"]<= e_)]

        # store them
        self.dfc = dfc
        self.dfh = dfh

        # update metric
        mism = len(dfc)
        dims = dfc["Dimension"].nunique() if not dfc.empty and "Dimension" in dfc.columns else 0
        self.metric_label.configure(text=f"Mismatches: {mism}, Dims: {dims}")

        # Now draw charts using these filtered sets
        self.plotHeatmap(dfc)
        self.plotLollipop(dfc)
        self.plotCircular(dfc)
        self.plotScatter(dfc)
        self.plotRadar(dfc)
        self.plotNormalPie(dfc)
        self.plotNormalBar(dfc)
        self.plotBandChart(dfh)  # pass dfh so we see runs in that date range

    def plot_chart(self, frame, fig):
        for w in frame.winfo_children():
            w.destroy()
        canvas = FigureCanvasTkAgg(fig, master=frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)

    # Paste your chart code, referencing the filtered data
    def plotHeatmap(self, dfc: pd.DataFrame):
        ...
    def plotLollipop(self, dfc: pd.DataFrame):
        ...
    def plotCircular(self, dfc: pd.DataFrame):
        ...
    def plotScatter(self, dfc: pd.DataFrame):
        ...
    def plotRadar(self, dfc: pd.DataFrame):
        ...
    def plotNormalPie(self, dfc: pd.DataFrame):
        ...
    def plotNormalBar(self, dfc: pd.DataFrame):
        ...
    def plotBandChart(self, dfh: pd.DataFrame):
        # same code, but uses dfh (already filtered by dimension/attribute/dates)
        if dfh.empty or "RunDate" not in dfh.columns:
            for w in self.frames["Band Chart"].winfo_children():
                w.destroy()
            return
        date_ct= dfh.groupby("RunDate")["Key"].count().reset_index(name="Count")
        date_ct.sort_values("RunDate", inplace=True)
        if date_ct.empty:
            for w in self.frames["Band Chart"].winfo_children():
                w.destroy()
            return
        date_ct["Count_min"] = date_ct["Count"]*0.9
        date_ct["Count_max"] = date_ct["Count"]*1.1
        fig, ax= plt.subplots(figsize=(6,4))
        ax.plot(date_ct["RunDate"], date_ct["Count"], color="purple", marker="o", label="Missing Count")
        ax.fill_between(date_ct["RunDate"], date_ct["Count_min"], date_ct["Count_max"],
                        color="purple", alpha=0.2, label="±10% band")
        ax.set_title("Band Chart Over Time")
        ax.set_xlabel("RunDate")
        ax.set_ylabel("Missing Count")
        plt.xticks(rotation=45)
        ax.legend()
        for i, row in date_ct.iterrows():
            ax.text(row["RunDate"], row["Count"], str(row["Count"]), ha="center", va="bottom")

        self.plot_chart(self.frames["Band Chart"], fig)

    def export_dashboard_pdf(self):
        from matplotlib.backends.backend_pdf import PdfPages
        pdf_dir = Path(self.master.config_dict["paths"].get("PDF_EXPORT_PATH","output/dashboard_reports"))
        pdf_dir.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        pdf_path = pdf_dir / f"dashboard_report_{timestamp}.pdf"

        with PdfPages(pdf_path) as pdf:
            # cover
            plt.figure(figsize=(8.5, 11))
            plt.axis('off')
            plt.text(0.5,0.8, "Reconciliation Dashboard Report", ha="center", fontsize=16)
            plt.text(0.5,0.7, f"Generated: {timestamp}", ha="center")
            if not self.df_current.empty:
                plt.text(0.5,0.6, f"Records in Current Run: {len(self.df_current)}", ha="center")
            pdf.savefig()
            plt.close()

            # each chart
            for name, frame in self.frames.items():
                for widget in frame.winfo_children():
                    if isinstance(widget, FigureCanvasTkAgg):
                        pdf.savefig(widget.figure)

        messagebox.showinfo("Success", f"PDF => {pdf_path}")


# ---------------------------------------------------------------------------
# MAIN APP
# ---------------------------------------------------------------------------
class MainApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Ultra-Mega Reconciliation: Param-based, Full Dashboard")
        self.geometry("1600x900")
        ctk.set_appearance_mode("light")

        # Load config + param
        self.config_dict = load_config(Path(DEFAULT_PATHS["CONFIG_PATH"]))
        self.param_dict = read_param_file(Path(self.config_dict["paths"].get("PARAMETER_PATH", DEFAULT_PATHS["PARAMETER_PATH"])))
        self.history_df = pd.DataFrame()  # for storing multiple runs

        self.tabs = ttk.Notebook(self)
        self.tabs.pack(fill="both", expand=True)

        # 1) Paths Tab
        self.tab_paths = ctk.CTkFrame(self.tabs)
        self.tabs.add(self.tab_paths, text="Paths")
        self.build_paths_tab(self.tab_paths)

        # 2) ERP Preview
        self.tab_erp = ctk.CTkFrame(self.tabs)
        self.erp_preview = SimplePreview(self.tab_erp, "ERP")
        self.erp_preview.pack(fill="both", expand=True)
        self.tabs.add(self.tab_erp, text="ERP Preview")

        # 3) Master Preview
        self.tab_master = ctk.CTkFrame(self.tabs)
        self.master_preview = SimplePreview(self.tab_master, "Master")
        self.master_preview.pack(fill="both", expand=True)
        self.tabs.add(self.tab_master, text="Master Preview")

        # 4) Compare
        self.tab_compare = ctk.CTkFrame(self.tabs)
        self.build_compare_tab(self.tab_compare)
        self.tabs.add(self.tab_compare, text="Compare")

        # 5) Dashboard
        self.dashboard_tab = AdvancedDashboard(self.tabs)
        self.dashboard_tab.master = self
        self.tabs.add(self.dashboard_tab, text="Dashboard")

        # Logging
        self.log_box = ctk.CTkTextbox(self, height=120)
        self.log_box.pack(fill="both")
        self.log_box.configure(state="disabled")
        handler = TextHandler(self.log_box)
        handler.setLevel(logging.INFO)
        logging.getLogger().addHandler(handler)

        # status bar
        self.add_status_bar()

        # Master CSV dir
        Path(self.config_dict["paths"].get("MASTER_CSV_OUTPUT","temp_master_csv")).mkdir(parents=True, exist_ok=True)

        # Auto load meltdown
        self.refresh_erp()
        self.refresh_master()

        self.setup_keyboard_shortcuts()
        self.add_tooltips()
        self.protocol("WM_DELETE_WINDOW", self.on_close)
        self.load_session()

    def build_paths_tab(self, parent):
        frm= ctk.CTkFrame(parent)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        self.erp_var= tk.StringVar(value=self.config_dict["paths"].get("ERP_EXCEL_PATH", DEFAULT_PATHS["ERP_EXCEL_PATH"]))
        self.mast_var= tk.StringVar(value=self.config_dict["paths"].get("MASTER_ZIP_PATH", DEFAULT_PATHS["MASTER_ZIP_PATH"]))
        self.exc_var= tk.StringVar(value=self.config_dict["paths"].get("EXCEPTION_PATH", DEFAULT_PATHS["EXCEPTION_PATH"]))
        self.out_var= tk.StringVar(value=self.config_dict["paths"].get("OUTPUT_PATH", DEFAULT_PATHS["OUTPUT_PATH"]))
        self.cfg_var= tk.StringVar(value=self.config_dict["paths"].get("CONFIG_PATH", DEFAULT_PATHS["CONFIG_PATH"]))
        self.par_var= tk.StringVar(value=self.config_dict["paths"].get("PARAMETER_PATH", DEFAULT_PATHS["PARAMETER_PATH"]))
        self.csv_var= tk.StringVar(value=self.config_dict["paths"].get("MASTER_CSV_OUTPUT", DEFAULT_PATHS["MASTER_CSV_OUTPUT"]))

        def mkrow(lbl, var, is_dir=False):
            rowf= ctk.CTkFrame(frm)
            rowf.pack(fill="x", pady=5)
            ctk.CTkLabel(rowf, text=lbl, width=180).pack(side="left", padx=5)
            e = ctk.CTkEntry(rowf, textvariable=var, width=600)
            e.pack(side="left", padx=5)
            def br():
                if is_dir:
                    d= filedialog.askdirectory()
                    if d:
                        var.set(d)
                else:
                    f= filedialog.askopenfilename()
                    if f:
                        var.set(f)
            ctk.CTkButton(rowf, text="Browse", command=br,
                          fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)

        mkrow("ERP Excel:", self.erp_var)
        mkrow("Master ZIP:", self.mast_var)
        mkrow("Exception Path:", self.exc_var)
        mkrow("Missing Items Output:", self.out_var)
        mkrow("JSON Config Path:", self.cfg_var)
        mkrow("Parameter File:", self.par_var)
        mkrow("Master CSV Folder:", self.csv_var, True)

        bf= ctk.CTkFrame(frm)
        bf.pack(fill="x", pady=10)
        ctk.CTkButton(bf, text="Save Config", command=self.save_all_config,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)
        ctk.CTkButton(bf, text="Refresh ERP", command=self.refresh_erp,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)
        ctk.CTkButton(bf, text="Refresh Master", command=self.refresh_master,
                      fg_color="#800020", hover_color="#a52a2a", text_color="white").pack(side="left", padx=5)

    def build_compare_tab(self, parent):
        frm= ctk.CTkFrame(parent)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        btn_frame = ctk.CTkFrame(frm)
        btn_frame.pack(fill="x", pady=5)

        ctk.CTkButton(
            btn_frame,
            text="🔄 Refresh All Data",
            command=self.refresh_all_data,
            fg_color="#800020",
            hover_color="#a52a2a",
            text_color="white",
            height=40
        ).pack(side="left", padx=5)

        compare_frame = ctk.CTkFrame(frm)
        compare_frame.pack(fill="x", pady=10)
        ctk.CTkLabel(
            compare_frame,
            text="Generate Missing Items Report",
            font=("Arial", 16)
        ).pack(pady=5)

        ctk.CTkButton(
            compare_frame,
            text="Run Reconciliation",
            command=self.run_comparison,
            fg_color="#800020",
            hover_color="#a52a2a",
            text_color="white",
            height=40
        ).pack(pady=5)

        self.status_frame = ctk.CTkFrame(frm)
        self.status_frame.pack(fill="x", pady=5)
        self.last_run_label = ctk.CTkLabel(
            self.status_frame,
            text="Last Run: Never"
        )
        self.last_run_label.pack(pady=5)

    def refresh_erp(self):
        erp_path= Path(self.erp_var.get()).resolve()
        raw_erp= read_erp_excel(erp_path)
        if raw_erp.empty:
            self.erp_preview.set_data(pd.DataFrame())
            return
        # read param
        param= read_param_file(Path(self.par_var.get()))
        melted= meltdown_erp_for_preview(raw_erp, param)
        pivoted= pivot_for_preview(melted)
        self.erp_preview.set_data(pivoted)

    def refresh_master(self):
        zip_path= Path(self.mast_var.get()).resolve()
        out_dir= Path(self.csv_var.get()).resolve()
        csvs= convert_master_txt_to_csv(zip_path, out_dir)
        raw_mast= unify_master_csvs(csvs)
        if raw_mast.empty:
            self.master_preview.set_data(pd.DataFrame())
            return
        param= read_param_file(Path(self.par_var.get()))
        melted= meltdown_master_for_preview(raw_mast, param)
        pivoted= pivot_for_preview(melted)
        self.master_preview.set_data(pivoted)

    def refresh_all_data(self):
        try:
            self.param_dict= read_param_file(Path(self.par_var.get()))
            self.refresh_erp()
            self.refresh_master()
            now_s= datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.last_run_label.configure(text=f"Last Refresh: {now_s}")
            messagebox.showinfo("Success","All data refreshed!")
        except Exception as e:
            logging.error(f"Refresh => {e}")
            messagebox.showerror("Error",f"{e}")

    def run_comparison(self):
        df_erp_wide= self.erp_preview.get_filtered_df()
        df_mast_wide= self.master_preview.get_filtered_df()

        erp_long= melt_back(df_erp_wide)
        erp_long= build_keys(erp_long)
        mast_long= melt_back(df_mast_wide)
        mast_long= build_keys(mast_long)

        df_diff= compare_mode2(erp_long, mast_long)
        exc_path= Path(self.exc_var.get()).resolve()
        df_exc= read_exception_table(exc_path)
        final= merge_exceptions(df_diff, df_exc)

        outp= Path(self.out_var.get()).resolve()
        write_missing_items(final, outp)

        run_date= datetime.now().strftime("%Y-%m-%d")
        final["RunDate"]= run_date
        if self.history_df.empty:
            self.history_df= final.copy()
        else:
            self.history_df= pd.concat([self.history_df, final], ignore_index=True)

        self.dashboard_tab.update_data(final, self.history_df)
        now_s= datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.last_run_label.configure(text=f"Last Run: {now_s}")
        messagebox.showinfo("Done", f"Missing => {outp}")

        self.tabs.select(self.dashboard_tab)

    def save_all_config(self):
        self.config_dict["paths"]["ERP_EXCEL_PATH"]= self.erp_var.get().strip()
        self.config_dict["paths"]["MASTER_ZIP_PATH"]= self.mast_var.get().strip()
        self.config_dict["paths"]["EXCEPTION_PATH"]= self.exc_var.get().strip()
        self.config_dict["paths"]["OUTPUT_PATH"]= self.out_var.get().strip()
        self.config_dict["paths"]["CONFIG_PATH"]= self.cfg_var.get().strip()
        self.config_dict["paths"]["PARAMETER_PATH"]= self.par_var.get().strip()
        self.config_dict["paths"]["MASTER_CSV_OUTPUT"]= self.csv_var.get().strip()

        path= Path(self.config_dict["paths"]["CONFIG_PATH"])
        save_config(self.config_dict, path)
        messagebox.showinfo("Saved","Paths & Config saved successfully.")

    def setup_keyboard_shortcuts(self):
        self.bind('<Control-r>', lambda e: self.refresh_all_data())
        self.bind('<Control-s>', lambda e: self.save_all_config())
        self.bind('<Control-e>', lambda e: self.dashboard_tab.export_dashboard_pdf())
        self.bind('<F5>', lambda e: self.refresh_all_data())

    def add_tooltips(self):
        pass

    def add_status_bar(self):
        self.status_bar= ctk.CTkFrame(self)
        self.status_bar.pack(fill="x", side="bottom")

        self.status_label= ctk.CTkLabel(self.status_bar, text="Ready")
        self.status_label.pack(side="left", padx=5)

        self.memory_label= ctk.CTkLabel(self.status_bar, text="")
        self.memory_label.pack(side="right", padx=5)

        self.update_status_bar()

    def update_status_bar(self):
        if psutil:
            process= psutil.Process()
            mem_mb= process.memory_info().rss/(1024*1024)
            self.memory_label.configure(text=f"Memory: {mem_mb:.1f} MB")
        else:
            self.memory_label.configure(text="psutil not installed")
        self.after(1000, self.update_status_bar)

    def save_session(self):
        session = {
            "config": self.config_dict,
            "filters": {
                "erp": self.erp_preview.filters,
                "master": self.master_preview.filters
            },
            "selected_dims": list(self.dashboard_tab.selected_dims),
            "selected_attrs": list(self.dashboard_tab.selected_attrs),
            "date_range": {
                "start": self.dashboard_tab.start_date_var.get(),
                "end": self.dashboard_tab.end_date_var.get()
            }
        }
        session_file= Path(self.config_dict["paths"]["CONFIG_PATH"]).parent / "last_session.json"
        try:
            with open(session_file,'w', encoding='utf-8') as f:
                json.dump(session, f, indent=2)
            logging.info(f"Session => {session_file}")
        except Exception as e:
            logging.error(f"Session => {e}")

    def load_session(self):
        session_file= Path(self.config_dict["paths"]["CONFIG_PATH"]).parent / "last_session.json"
        if session_file.is_file():
            try:
                with open(session_file,'r', encoding='utf-8') as f:
                    sess= json.load(f)
                self.config_dict= sess["config"]
                self.erp_preview.filters= sess["filters"]["erp"]
                self.master_preview.filters= sess["filters"]["master"]
                self.dashboard_tab.selected_dims= set(sess["selected_dims"])
                self.dashboard_tab.selected_attrs= set(sess["selected_attrs"])
                self.dashboard_tab.start_date_var.set(sess["date_range"]["start"])
                self.dashboard_tab.end_date_var.set(sess["date_range"]["end"])
                logging.info("Session loaded.")
            except Exception as e:
                logging.error(f"Session load => {e}")

    def on_close(self):
        self.save_session()
        self.destroy()

def main():
    app= MainApp()
    app.mainloop()

if __name__=="__main__":
    main()
