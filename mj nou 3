Option Explicit

'--------------------------------------------------------------------------------------------
' MAIN: Refresh Smart View hierarchies, then build queries
'--------------------------------------------------------------------------------------------
Public Sub RefreshHierarchiesAndCreateQueries()
    On Error GoTo errHandler
    
    LogMessage "RefreshHierarchiesAndCreateQueries", "INFO", "Process started."
    
    ' Step 1) Refresh each sheet (original working version)
    RefreshSmartViewTree
    
    ' Step 2) Create or update queries named <SheetName>_FlatTable
    '         The M code will remove last row(s) if Tree/List, then do bottom-up parent detection
    CreateHierarchyQueries
    
    LogMessage "RefreshHierarchiesAndCreateQueries", "INFO", "Process completed successfully."
    Exit Sub

errHandler:
    LogError "RefreshHierarchiesAndCreateQueries", Err.Number, Err.Description
End Sub

'--------------------------------------------------------------------------------------------
' (1) REFRESH SMART VIEW HIERARCHIES - ORIGINAL WORKING VERSION
'--------------------------------------------------------------------------------------------
Public Sub RefreshSmartViewTree()
    On Error GoTo errHandler
    
    Dim arrSheets As Variant
    Dim ws As Worksheet
    Dim wsLists As Worksheet
    Dim ConnectionName As String
    Dim Ret As Long, HeaderRow As Long, LastRow As Long, i As Long
    Dim ConnStatus As Integer
    
    ' Identify "Lists" sheet
    Set wsLists = ThisWorkbook.Worksheets("Lists")
    
    With wsLists
        ConnectionName = .Range("nmConnectionName").Value
        arrSheets = .Range("Hierarchy_Matrix").Value
    End With
    
    HeaderRow = 4
    
    ' For each row in Hierarchy_Matrix
    For i = LBound(arrSheets) To UBound(arrSheets)
        Dim sheetName As String, rangeName As String
        sheetName = arrSheets(i, 1)
        rangeName = arrSheets(i, 2)
        
        Set ws = ThisWorkbook.Worksheets(sheetName)
        
        With ws
            ' Connect to Smart View
            Ret = HypUIConnect(.Name, "", "", ConnectionName)
            ConnStatus = HypConnected(.Name)
            If ConnStatus <> -1 Then Stop ' your debug check
            
            ' Delete old rows except the final one
            LastRow = .Range("A" & .Rows.Count).End(xlUp).Row
            If LastRow > HeaderRow Then
                .Rows(HeaderRow & ":" & LastRow - 1).Delete Shift:=xlUp
            End If
            LastRow = .Range("A" & .Rows.Count).End(xlUp).Row
            
            ' Set member display
            Ret = HypSetSheetOption(.Name, HYP_SVC_OPTIONS_INDEX.HSV_MEMBER_DISPLAY, 1)
            
            ' Zoom in
            Ret = HypZoomIn(.Name, .Range("A" & LastRow), 1, False)
            
            ' Recalc last row
            LastRow = .Range("A" & .Rows.Count).End(xlUp).Row
            
            ' Delete old named range if exists
            On Error Resume Next
            ThisWorkbook.Names(rangeName).Delete
            On Error GoTo 0
            
            ' Create named range row4..LastRow
            ThisWorkbook.Names.Add Name:=rangeName, _
                RefersTo:=.Range("A" & HeaderRow & ":A" & LastRow)
        End With
    Next i
    
    LogMessage "RefreshSmartViewTree", "INFO", "Smart View refresh completed."
    Exit Sub

errHandler:
    LogError "RefreshSmartViewTree", Err.Number, Err.Description
End Sub

'--------------------------------------------------------------------------------------------
' (2) CREATE HIERARCHY QUERIES
'     M code removes last row if Tree, last 2 if List, then bottom-up indentation parent
'--------------------------------------------------------------------------------------------
Public Sub CreateHierarchyQueries()
    On Error GoTo errHandler
    
    LogMessage "CreateHierarchyQueries", "INFO", "Starting query creation..."
    
    Dim wsLists As Worksheet
    Dim arrSheets As Variant
    Dim i As Long
    
    Set wsLists = ThisWorkbook.Worksheets("Lists")
    arrSheets = wsLists.Range("Hierarchy_Matrix").Value
    
    For i = LBound(arrSheets) To UBound(arrSheets)
        Dim sheetName As String, rangeName As String
        Dim queryName As String, queryText As String
        Dim ws As Worksheet
        Dim treeOrList As String
        
        sheetName = Trim(arrSheets(i, 1))
        rangeName = Trim(arrSheets(i, 2))
        
        If sheetName = "" Or rangeName = "" Then GoTo SkipThis
        
        queryName = sheetName & "_FlatTable"
        
        ' read D7 from that sheet for "Tree"/"List"
        Set ws = ThisWorkbook.Worksheets(sheetName)
        treeOrList = UCase(Trim(ws.Range("D7").Value))
        
        ' build M code
        queryText = BuildBottomUpParentQuery(rangeName, treeOrList)
        
        ' create or update the query
        On Error Resume Next
        ThisWorkbook.Queries(queryName).Formula = queryText
        If Err.Number <> 0 Then
            On Error Resume Next
            ThisWorkbook.Connections(queryName).Delete
            On Error GoTo 0
            ThisWorkbook.Queries.Add Name:=queryName, Formula:=queryText
        End If
        On Error GoTo 0
        
        LogMessage "CreateHierarchyQueries", "INFO", _
                   "Sheet='" & sheetName & "', Query='" & queryName & "', Mode='" & treeOrList & "'"
SkipThis:
    Next i
    
    LogMessage "CreateHierarchyQueries", "INFO", "Done creating queries."
    Exit Sub

errHandler:
    LogError "CreateHierarchyQueries", Err.Number, Err.Description
End Sub

'--------------------------------------------------------------------------------------------
' BUILD BOTTOM-UP INDENT PARENT QUERY
'  - If "Tree", remove last 1 row in M code
'  - If "List", remove last 2 rows in M code
'  - Then do parent detection: for each row i, find row j below i with smaller Indent?
'    Or row j above i with smaller Indent? We'll do the typical approach: row j < i => smaller Indent
'  - Return final table in top->bottom order
'--------------------------------------------------------------------------------------------
Public Function BuildBottomUpParentQuery(rangeName As String, treeOrList As String) As String
    Dim skipRows As Long
    
    If treeOrList = "TREE" Then
        skipRows = 1
    ElseIf treeOrList = "LIST" Then
        skipRows = 2
    Else
        skipRows = 0
    End If
    
    Dim mCode As String
    
    mCode = "let" & vbCrLf
    mCode = mCode & "    // 1) Load entire named range" & vbCrLf
    mCode = mCode & "    Source = Excel.CurrentWorkbook(){[Name=""" & rangeName & """]}[Content]," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // 2) Remove last 1 or 2 rows if Tree or List" & vbCrLf
    mCode = mCode & "    rowCount = Table.RowCount(Source)," & vbCrLf
    mCode = mCode & "    dataRows = if rowCount > " & skipRows & " " & _
                   "then Table.FirstN(Source, rowCount - " & skipRows & ") else Source," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // 3) Filter out blank lines" & vbCrLf
    mCode = mCode & "    filtered = Table.SelectRows(dataRows, each [Column1] <> null and [Column1] <> """")," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // 4) Add an index in top->bottom order" & vbCrLf
    mCode = mCode & "    indexed = Table.AddIndexColumn(filtered, ""RowIndex"", 0, 1, Int64.Type)," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // 5) Compute Indent, Trim Value" & vbCrLf
    mCode = mCode & "    withIndent = Table.AddColumn(indexed, ""Indent"", each Text.Length([Column1]) - Text.Length(Text.TrimStart([Column1])), Int64.Type)," & vbCrLf
    mCode = mCode & "    withValue = Table.AddColumn(withIndent, ""Value"", each Text.Trim([Column1]), type text)," & vbCrLf
    mCode = mCode & "    baseTable = Table.SelectColumns(withValue, {""RowIndex"", ""Indent"", ""Value""})," & vbCrLf
    mCode = mCode & "    buffered = Table.Buffer(baseTable)," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // 6) Bottom-up parent detection in top->bottom order" & vbCrLf
    mCode = mCode & "    // For each row i, find the row j where j < i (above in the table) with smaller Indent" & vbCrLf
    mCode = mCode & "    // picking the closest row above => the largest j < i" & vbCrLf
    mCode = mCode & "    withParent = Table.AddColumn(buffered, ""Parent"", (thisRow) => let" & vbCrLf
    mCode = mCode & "        myIdx = thisRow[RowIndex]," & vbCrLf
    mCode = mCode & "        myIndent = thisRow[Indent]," & vbCrLf
    mCode = mCode & "        candidates = Table.SelectRows(buffered, each [RowIndex] < myIdx and [Indent] < myIndent)," & vbCrLf
    mCode = mCode & "        sorted = Table.Sort(candidates, {{""RowIndex"", Order.Descending}})," & vbCrLf
    mCode = mCode & "        pick = if Table.IsEmpty(sorted) then null else sorted{0}[Value]" & vbCrLf
    mCode = mCode & "    in pick )," & vbCrLf
    mCode = mCode & vbCrLf
    mCode = mCode & "    // 7) Keep final columns in top->bottom order" & vbCrLf
    mCode = mCode & "    final = Table.SelectColumns(withParent, {""Value"", ""Parent""})" & vbCrLf
    mCode = mCode & "in" & vbCrLf
    mCode = mCode & "    final"
    
    BuildBottomUpParentQuery = mCode
End Function

'--------------------------------------------------------------------------------------------
' LOG SHEET
'--------------------------------------------------------------------------------------------
Public Sub LogMessage(procName As String, msgType As String, message As String)
    Dim wsLog As Worksheet
    Dim nextRow As Long
    
    On Error Resume Next
    Set wsLog = ThisWorkbook.Worksheets("Log")
    On Error GoTo 0
    
    If wsLog Is Nothing Then
        Set wsLog = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
        wsLog.Name = "Log"
        wsLog.Range("A1").Value = "Timestamp"
        wsLog.Range("B1").Value = "Procedure"
        wsLog.Range("C1").Value = "Type"
        wsLog.Range("D1").Value = "Message"
    End If
    
    nextRow = wsLog.Cells(wsLog.Rows.Count, 1).End(xlUp).Row + 1
    wsLog.Cells(nextRow, 1).Value = Format(Now, "yyyy-mm-dd HH:mm:ss")
    wsLog.Cells(nextRow, 2).Value = procName
    wsLog.Cells(nextRow, 3).Value = msgType
    wsLog.Cells(nextRow, 4).Value = message
End Sub

Public Sub LogError(procName As String, errNumber As Long, errDescription As String)
    LogMessage procName, "ERROR", "Error #" & errNumber & ": " & errDescription
End Sub
